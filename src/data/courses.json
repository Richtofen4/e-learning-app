[
  {
    "id": 1,
    "title": "Kurs C++ – Kompletne wprowadzenie do programowania w C++",
    "image": "/images/C++.png",
    "duration": "1-2 godziny",
    "category": "Programowanie",
    "categoryGroup": "programowanie",
    "welcomeMessage": "Ten kurs zawiera pełne wprowadzenie do programowania w języku C++, obejmujące podstawy i elementy średniozaawansowane. Kurs został zainspirowany stylem Akademia Park (struktura modułów) oraz formą prezentacji wiedzy z w3schools (zwięzłe wyjaśnienia poparte przykładami kodu). Znajdziesz tu informacje o składni C++, typach danych, operacjach, sterowaniu przepływem programu, funkcjach, tablicach, wskaźnikach oraz podstawach programowania obiektowego (klasy, dziedziczenie, polimorfizm). Wiedza podzielona jest na logiczne moduły, z których każdy zawiera kilka sekcji tematycznych z przykładami kodu i materiałami dodatkowymi.",
    "objectives": [
      "Poznasz podstawową składnię języka C++ i nauczysz się pisać proste programy",
      " Zrozumiesz jak działają zmienne, typy danych, operatory, instrukcje warunkowe i pętle",
      "Nauczysz się tworzyć funkcje, korzystać z tablic oraz poprawnie wprowadzać i wyprowadzać dane",
      "Zdobędziesz solidne podstawy, które przygotują Cię do nauki bardziej zaawansowanych tematów programowania w C++"
    ],
    "modules": [
      {
        "id": 1,
        "title": "Wprowadzenie i składnia języka C++",
        "description": "Moduł ten omawia podstawy języka C++, jego składnię, sposób kompilacji oraz uruchamiania programów.",
        "lessons": [
          {
            "id": 1,
            "title": "Wprowadzenie do C++",
            "content": "<p>C++ to wydajny język programowania ogólnego przeznaczenia, stworzony przez Bjarne Stroustrupa jako rozszerzenie języka C w celu dodania paradygmatu obiektowego. Jest to język kompilowany, co oznacza, że kod źródłowy musi zostać przetłumaczony przez kompilator na kod maszynowy zrozumiały dla komputera. C++ obsługuje różne style programowania: proceduralny, obiektowy, funkcyjny i inne.</p><p>Dzięki swojej wydajności i wszechstronności C++ pozostaje szeroko stosowany w różnych dziedzinach, od systemów operacyjnych i przeglądarek po gry i aplikacje finansowe.</p><p>Kompilator i uruchamianie programu: Aby pisać programy w C++, potrzebny jest kompilator (np. GCC, Clang lub MSVC) lub środowisko programistyczne (IDE) zawierające kompilator. Przykładowo, w systemie Linux kompilacja odbywa się przez:</p><pre><code>g++ nazwa_pliku.cpp -o nazwa_programu\n./nazwa_programu</code></pre><p>W środowiskach IDE (np. Visual Studio, Code::Blocks) wystarczy kliknąć przycisk >Uruchom</strong>.</p><p>„Hello World” – pierwszy program:</strong> Tradycyjnie naukę C++ zaczyna się od programu wypisującego tekst <em>Hello, World!</em> na ekran.</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}</code></pre></div><p><strong>Omówienie:</strong> Linia <code>#include &lt;iostream&gt;</code> dołącza bibliotekę standardową odpowiedzialną za wejście/wyjście. <code>using namespace std;</code> upraszcza zapis operatorów (np. <code>cout</code> zamiast <code>std::cout</code>). Funkcja <code>main()</code> to punkt startowy programu. Instrukcja <code>cout</code> wyświetla tekst, a <code>return 0;</code> informuje o poprawnym zakończeniu programu.</p><p><strong>Komentarze:</strong> W C++ można stosować komentarze:</p><ul><li><code>// komentarz jednoliniowy</code></li><li><code>/* komentarz blokowy */</code></li></ul><p>Używanie komentarzy ułatwia zrozumienie kodu i poprawia jego czytelność, szczególnie w złożonych projektach.</p>"
          },
          {
            "id": 2,
            "title": "Podstawowa składnia C++ – rozszerzenie",
            "content": "<p>Składnia C++ w dużej mierze opiera się na składni języka C. Podczas programowania w C++ należy przestrzegać kilku podstawowych reguł składniowych:</p><ul><li><strong>Struktura programu:</strong> Typowy program w C++ składa się z dyrektyw preprocesora (np. <code>#include &lt;...&gt;</code>), deklaracji funkcji i zmiennych globalnych oraz definicji funkcji – w tym koniecznie funkcji <code>main()</code>. Kod funkcji (instrukcje) umieszczamy wewnątrz nawiasów klamrowych <code>{ }</code>. Bloki kodu (np. ciało funkcji, pętle, instrukcje warunkowe) również ograniczamy klamrami. Klamry wyznaczają zakres (tzw. <em>blok</em>), w którym obowiązują deklaracje zmiennych.</li><li><strong>Instrukcje i średniki:</strong> Pojedyncza instrukcja (np. wywołanie funkcji <code>cout &lt;&lt; \"tekst\";</code> czy przypisanie wartości do zmiennej <code>x = 5;</code>) musi kończyć się średnikiem <code>;</code>. Średnik informuje kompilator o końcu instrukcji. Pominięcie średnika najczęściej powoduje błąd kompilacji.</li><li><strong>Wielkość liter:</strong> Język C++ rozróżnia wielkość liter. Nazwy takie jak <code>warszawa</code> i <code>Warszawa</code> będą traktowane jako dwa różne identyfikatory. Dotyczy to zarówno nazw zmiennych, funkcji, jak i słów kluczowych – np. <code>int</code> musi być napisane małymi literami (INT lub Int nie zostanie rozpoznane).</li><li><strong>Białe znaki:</strong> Spacje, tabulatory i znaki nowej linii (tzw. <em>białe znaki</em>) są generalnie ignorowane przez kompilator (wyjątkiem jest ich rola jako separatorów między tokenami). Można formatować kod wcięciami i nowymi liniami dla czytelności. Konwencja jest taka, by używać wcięć (np. 4 spacje) wewnątrz bloków <code>{ }</code>, aby wizualnie zaznaczyć zagnieżdżenie kodu.</li><li><strong>Nazewnictwo i identyfikatory:</strong> Nazwa zmiennej, funkcji czy klasy (tzw. identyfikator) powinna zaczynać się od litery (lub znaku podkreślenia <code>_</code>) i może składać się z liter, cyfr oraz znaku podkreślenia. Niedozwolone są spacje i znaki specjalne. Przykłady poprawnych nazw: <code>licznik</code>, <code>Sum1</code>, <code>_tmp</code>. Pamiętaj o czytelnych nazwach – np. <code>wiek</code> zamiast <code>w</code> – ułatwi to zrozumienie kodu.</li></ul><p><strong>Przykład formatowania kodu:</strong> Zwróć uwagę na czytelność poniższego kodu dzięki zastosowaniu wcięć i pustych linii:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 10;\n    if (x &gt; 0) {\n        cout &lt;&lt; \"x jest dodatnie\";\n    } else {\n        cout &lt;&lt; \"x nie jest dodatnie\";\n    }\n    return 0;\n}</code></pre></div><p>W powyższym kodzie widać, że instrukcje wewnątrz <code>if / else</code> zostały wcięte, a całość funkcji <code>main</code> również jest przesunięta względem deklaracji funkcji. Takie formatowanie nie jest wymagane przez kompilator, ale stanowi dobrą praktykę i znacznie poprawia czytelność kodu.</p>"
          }
        ]
      },
      {
        "id": 2,
        "title": "Zmienne i  typy danych",
        "description": "",
        "lessons": [
          {
            "id": 1,
            "title": "Zmienne i typy danych podstawowe",
            "content": "<p><strong>Zmienne</strong> stanowią podstawowy sposób przechowywania danych w programie. Zmienna to po prostu nazwana lokacja w pamięci, w której można zapisać pewną wartość (i później ją odczytać lub zmodyfikować). Każda zmienna w C++ ma <em>typ danych</em>, który określa jakiego rodzaju wartości może przechowywać oraz ile miejsca zajmie w pamięci.</p><p>Przykładowo, zmienna typu całkowitoliczbowego (<code>int</code>) może przechowywać liczby całkowite (bez części ułamkowej) z pewnego zakresu, a zmienna typu znakowego (<code>char</code>) przechowuje pojedyncze znaki.</p><p><strong>Deklaracja i inicjalizacja:</strong> Aby korzystać ze zmiennej, najpierw <em>deklarujemy</em> ją, podając jej typ i nazwę. Opcjonalnie można od razu przypisać jej wartość (inicjalizacja). Przykład:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int liczba;         // deklaracja zmiennej typu całkowitego (wartość nieokreślona)\nint a = 5;          // deklaracja zmiennej i inicjalizacja na 5\ndouble pi = 3.14;   // zmienna typu double (liczba zmiennoprzecinkowa)\nchar znak = 'A';    // zmienna typu char (pojedynczy znak)\nbool isReady = false; // zmienna typu bool (logiczny) z wartością false (fałsz)</code></pre></div><p>Po zadeklarowaniu zmiennej możemy jej używać w dalszej części programu, odwołując się do niej po nazwie. <strong>Uwaga:</strong> Dopóki nie przypiszemy zmiennej wartości, jej zawartość jest niezdefiniowana – zawsze warto ją zainicjalizować przed użyciem.</p><p><strong>Typy danych w C++:</strong> C++ udostępnia szereg podstawowych typów:</p><ul><li><strong>Liczby całkowite:</strong> <code>int</code> (zwykle 32-bit), <code>short</code> (16-bit), <code>char</code> (8-bit), <code>long</code>, <code>long long</code>.</li><li><strong>Liczby zmiennoprzecinkowe:</strong> <code>float</code> (ok. 6-7 cyfr znaczących), <code>double</code> (ok. 15 cyfr znaczących). Przykład: <code>double srednia = 4.5;</code></li><li><strong>Typ logiczny:</strong> <code>bool</code> – wartości <code>true</code> (prawda) lub <code>false</code> (fałsz).</li><li><strong>Typ znakowy:</strong> <code>char</code> – przechowuje pojedynczy znak, np. <code>'a'</code>, <code>'2'</code>, <code>'@'</code>.</li><li><strong>Łańcuchy znaków:</strong> <code>std::string</code> (z biblioteki <code>&lt;string&gt;</code>) – do przechowywania tekstu. Przykład: <code>std::string imie = \"Jan\";</code></li></ul><p>Każdy typ określa zakres możliwych wartości. Np. <code>int</code> przechowuje liczby całkowite z zakresu ok. -2 miliardów do +2 miliardów, a <code>float</code> ok. 7 cyfr znaczących (np. <code>3.1415926</code> może zostać ucięte do <code>3.141593</code>).</p><p><strong>Stałe:</strong> Można definiować wartości, które nie mogą się zmieniać – tzw. <code>const</code>:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>const double PI = 3.1415926535;\nconst int DNI_TYGODNIA = 7;</code></pre></div><p>Zmiennych takich nie można nadpisywać. Każda próba przypisania nowej wartości zakończy się błędem kompilacji.</p><p><strong>Konwersje typów:</strong> W C++ wyrażenia muszą mieć zgodne typy – dlatego czasem trzeba jawnie lub niejawnie przekonwertować dane. Przykłady:</p><ul><li><strong>Niejawne:</strong> <code>int a = 5; double b = 2.5; auto c = a + b;</code> – <code>a</code> zostanie rzutowane do <code>double</code>.</li><li><strong>Jawne:</strong> <code>double d = (double)3 / 2;</code> – rzutowanie, by uzyskać wynik <code>1.5</code>, a nie <code>1</code>.</li></ul><p>Warto uważać przy rzutowaniu (szczególnie z <code>double</code> na <code>int</code>), ponieważ może to prowadzić do utraty danych.</p>"
          },
          {
            "id": 2,
            "title": "Wejście i wyjście danych (cin/cout)",
            "content": "<p>W typowych programach konieczne jest uzyskanie danych od użytkownika oraz wyświetlanie wyników. W C++ służą do tego <strong>strumienie wejścia i wyjścia</strong> z biblioteki <code>&lt;iostream&gt;</code>:</p><ul><li><strong><code>std::cout</code></strong> – strumień wyjściowy (ang. <em>console output</em>) używany do wypisywania na ekran (domyślnie na konsolę). Używa operatora <code>&lt;&lt;</code> do przekazywania danych do wyświetlenia.</li><li><strong><code>std::cin</code></strong> – strumień wejściowy (ang. <em>console input</em>) służący do pobierania danych od użytkownika z klawiatury. Używa operatora <code>&gt;&gt;</code> (przeciwny kierunek do cout) do wczytywania wartości do zmiennych.</li></ul><p>Poniższy przykład demonstruje proste wykorzystanie <code>cin</code> i <code>cout</code>:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int wiek;\n    cout &lt;&lt; \"Podaj swój wiek: \";\n    cin &gt;&gt; wiek;\n    cout &lt;&lt; \"Twój wiek to \" &lt;&lt; wiek &lt;&lt; \" lat.\" &lt;&lt; endl;\n    return 0;\n}</code></pre></div><p><strong>Omówienie:</strong> Program najpierw deklaruje zmienną całkowitą <code>wiek</code>. Następnie za pomocą <code>cout</code> wypisuje komunikat proszący użytkownika o podanie wieku. Funkcja <code>cin</code> wstrzymuje działanie programu, oczekując na wprowadzenie danych przez użytkownika. Wpisana liczba zostaje przypisana do zmiennej <code>wiek</code>, a następnie za pomocą <code>cout</code> wypisywane jest zdanie zawierające tę wartość.</p><p>Zauważ użycie operatora <code>&lt;&lt;</code> kilkukrotnie w jednej instrukcji – możemy łączyć teksty i zmienne w jednym wypisaniu. Po zakończeniu linii dodano <code>&lt;&lt; endl</code>, który przenosi kursor do nowej linii i opróżnia bufor wyjściowy.</p><p><strong>Wskazówki:</strong></p><ul><li><code>cin</code> domyślnie rozdziela dane po <em>białych znakach</em>, np. spacja, enter – przy wpisywaniu tekstu zatrzyma się na pierwszym znaku białym.</li><li>Aby wczytać całe zdanie (łącznie ze spacjami), użyj funkcji <code>std::getline</code>.</li><li>Jeśli użytkownik wpisze dane w formacie niezgodnym z oczekiwanym (np. tekst zamiast liczby), <code>cin</code> wejdzie w stan błędu i zmienne nie zostaną zmienione. W poważniejszych programach trzeba to obsłużyć przez <code>cin.fail()</code>.</li></ul>"
          }   
        ]
      },
      {
        "id": 3,
        "title": "Zmienne i  typy danych",
        "description": "",
        "lessons": [
          {
            "id": 1,
            "title": "Operatory arytmetyczne i przypisania",
            "content": "<p><strong>Operatory arytmetyczne</strong> pozwalają wykonywać podstawowe działania matematyczne na liczbach:</p><ul><li><code>+</code> (dodawanie)</li><li><code>-</code> (odejmowanie)</li><li><code>*</code> (mnożenie)</li><li><code>/</code> (dzielenie)</li><li><code>%</code> (reszta z dzielenia, modulo)</li></ul><p><strong>Przykład użycia:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int a = 10, b = 3;\ncout &lt;&lt; a + b;  // wypisze 13 (10 + 3)\ncout &lt;&lt; a - b;  // wypisze 7  (10 - 3)\ncout &lt;&lt; a * b;  // wypisze 30 (10 * 3)\ncout &lt;&lt; a / b;  // wypisze 3  (dzielenie całkowite 10 / 3)\ncout &lt;&lt; a % b;  // wypisze 1  (reszta z dzielenia 10 przez 3 to 1)</code></pre></div><p>Zwróć uwagę: jeśli dzielisz liczby całkowite, wynik też będzie całkowity – część ułamkowa zostaje odcięta. Aby uzyskać wynik z ułamkiem, przynajmniej jeden z operandów musi być typu zmiennoprzecinkowego (np. <code>10.0 / 3</code> daje <code>3.333...</code>). Operator <code>%</code> działa tylko na liczbach całkowitych i zwraca resztę z dzielenia.</p><h3>Operatory przypisania</h3><p>Podstawowy operator przypisania to <code>=</code>. Umożliwia przypisanie wartości do zmiennej:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int x = 5;</code></pre></div><p>Można też tworzyć łańcuchy przypisań:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int a, b;\na = b = 0; // ustawia a i b na 0</code></pre></div><h3>Złożone operatory przypisania</h3><p>C++ udostępnia operatory łączące przypisanie z działaniem arytmetycznym:</p><ul><li><code>+=</code> (dodaj i przypisz), np. <code>x += 3;</code></li><li><code>-=</code> (odejmij i przypisz), np. <code>y -= 2;</code></li><li><code>*=</code> (pomnóż i przypisz), np. <code>z *= 10;</code></li><li><code>/=</code> i <code>%=</code> – analogicznie do dzielenia i modulo</li></ul><p>Przykład użycia:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int num = 8;\nnum += 2; // num = 10\nnum -= 3; // num = 7\nnum *= 5; // num = 35\nnum /= 7; // num = 5\ncout &lt;&lt; num; // wypisze 5</code></pre></div><h3>Inkrementacja i dekrementacja</h3><p>Do zwiększania lub zmniejszania wartości o 1 służą operatory:</p><ul><li><code>++</code> – inkrementacja</li><li><code>--</code> – dekrementacja</li></ul><p>Można je stosować jako:</p><ul><li><strong>postfiksowe</strong> (po zmiennej): <code>i++</code></li><li><strong>prefiksowe</strong> (przed zmienną): <code>++i</code></li></ul><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int i = 7;\ni++;  // post: zwiększa i do 8\n++i;  // pre: zwiększa i do 9</code></pre></div><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int j = 5;\nint k = j++;\n// k = 5 (wartość przed zwiększeniem), j = 6\nint m = ++j;\n// j = 7, m = 7 (wartość po zwiększeniu)</code></pre></div><p>Różnica: <code>i++</code> zwraca wartość przed zwiększeniem, <code>++i</code> po zwiększeniu. W prostych instrukcjach nie ma to większego znaczenia, ale w złożonych wyrażeniach warto uważać, aby uniknąć nieczytelności lub błędów logicznych.</p>"
          },
          {
            "id": 2,
            "title": "Operatory porównania i logiczne",
            "content": "<p>Do porównywania wartości służą <strong>operatory porównania</strong>. Wynikiem porównania jest wartość logiczna <code>true</code> (prawda) lub <code>false</code> (fałsz):</p><ul><li><code>==</code> – równość (zwraca <code>true</code>, jeśli oba operandy są równe). Np. <code>x == y</code> jest <code>true</code> gdy <code>x</code> i <code>y</code> mają taką samą wartość.</li><li><code>!=</code> – różność (<code>true</code>, jeśli operandy nie są równe). Np. <code>x != 0</code> jest <code>true</code>, gdy <code>x</code> ma wartość inną niż 0.</li><li><code>&gt;</code> – większy niż; <code>&lt;</code> – mniejszy niż.</li><li><code>&gt;=</code> – większy lub równy; <code>&lt;=</code> – mniejszy lub równy.</li></ul><p>Przykład:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int a = 5, b = 8;\nbool wynik1 = (a == b);   // false, bo 5 nie jest równe 8\nbool wynik2 = (a &lt; b);    // true, bo 5 jest mniejsze od 8\nbool wynik3 = (a &gt;= 0);   // true, bo 5 &gt;= 0\nbool wynik4 = (a != b);   // true, bo 5 != 8</code></pre></div><p>Zmienne <code>wynik1</code>, <code>wynik2</code> itd. typu <code>bool</code> przechowują rezultat porównań. Można je też od razu użyć w instrukcjach warunkowych.</p><p>W języku C++ wartości logiczne <code>true</code> i <code>false</code> są wewnętrznie reprezentowane jako <code>1</code> i <code>0</code>. Jeśli spróbujemy wypisać zmienną typu <code>bool</code> przez <code>cout</code>, domyślnie zobaczymy 1 dla <code>true</code> lub 0 dla <code>false</code>. Można to zmienić używając:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>cout &lt;&lt; boolalpha &lt;&lt; zmienna_bool;</code></pre></div><p>Dzięki temu <code>true</code> / <code>false</code> będą wypisane słownie.</p><h3>Operatory logiczne</h3><p>Pozwalają łączyć warunki (wartości boolowskie) oraz negować pojedyncze:</p><ul><li><code>&amp;&amp;</code> – koniunkcja (AND, logiczne „i”): <code>expr1 &amp;&amp; expr2</code> jest <code>true</code> tylko jeśli oba wyrażenia są <code>true</code>.</li><li><code>||</code> – alternatywa (OR, logiczne „lub”): <code>expr1 || expr2</code> jest <code>true</code>, jeśli co najmniej jedno z wyrażeń jest <code>true</code>.</li><li><code>!</code> – negacja (NOT, logiczne „nie”): <code>!expr</code> jest <code>true</code>, jeśli <code>expr</code> jest <code>false</code>.</li></ul><p>Przykład:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int x = 7;\nbool warunek = (x &gt; 0) &amp;&amp; (x &lt; 10);       // true, x jest jednocześnie &gt; 0 i &lt; 10\nbool warunek2 = (x % 2 == 0) || (x &lt; 0);   // false, x nie jest parzyste ani ujemne\nbool odwrotny = !warunek;                  // false, odwrotność wartości warunek</code></pre></div><h3>Objaśnienie:</h3><ul><li><code>warunek</code> będzie <code>true</code>, jeśli <code>x</code> jest większe od 0 <em>i</em> jednocześnie mniejsze od 10. Dla <code>x = 7</code> to prawda.</li><li><code>warunek2</code> będzie <code>true</code>, jeśli <code>x</code> jest liczbą parzystą <em>lub</em> ujemną. <code>x = 7</code> nie spełnia żadnego z warunków – wynik to <code>false</code>.</li><li><code>odwrotny</code> to negacja <code>warunek</code>. Skoro <code>warunek</code> był <code>true</code>, <code>odwrotny</code> to <code>false</code>.</li></ul><h3>Właściwości operatorów logicznych</h3><p><code>&amp;&amp;</code> i <code>||</code> są <strong>leniwe</strong> – jeśli wartość całego wyrażenia można ustalić po sprawdzeniu pierwszego warunku, drugi nie jest w ogóle ewaluowany:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>if (ptr != nullptr &amp;&amp; *ptr &gt; 0) { ... }</code></pre></div><p>Jeśli <code>ptr</code> jest puste, <code>*ptr</code> nie zostanie sprawdzone, co chroni przed błędem. Takie podejście poprawia wydajność i bezpieczeństwo.</p><h3>Priorytety operatorów</h3><p>Operatory arytmetyczne, porównania i logiczne mają zdefiniowany priorytet (kolejność wykonywania). Najwyższy ma <code>!</code>, potem porównania (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>), a najniższy <code>&amp;&amp;</code> i <code>||</code>. W razie wątpliwości używaj nawiasów, np.:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>x &lt; b || a &lt; c &amp;&amp; d == e</code></pre></div><p>To równoważne z:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>x &lt; b || (a &lt; c &amp;&amp; d == e)</code></pre></div><p>Jeśli chcesz wymusić inną kolejność, użyj nawiasów zgodnie z zamierzeniem.</p>"
          }
        ]
      },
      {
        "id": 4,
        "title": "Pętle",
        "description": "",
        "lessons": [
          {
            "id": 1,
            "title": "Instrukcja if ... else",
            "content": "<p><strong>Instrukcje warunkowe</strong> pozwalają wykonać określony blok kodu tylko wtedy, gdy spełniony jest zadany warunek logiczny. Podstawową konstrukcją jest <code>if</code>. Składnia wygląda następująco:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>if (warunek) {\n    // blok kodu wykonywany, gdy warunek jest spełniony (true)\n}</code></pre></div><p>W nawiasie po <code>if</code> umieszczamy wyrażenie, które zostanie zinterpretowane jako warunek logiczny. Jeśli wynik tego wyrażenia jest <code>true</code> (lub wartość niezerowa w przypadku liczbowym), wykonywany jest blok instrukcji w klamrach. Jeśli wynik to <code>false</code> (zero), blok jest pomijany.</p><p>Często chcemy wykonać alternatywne działania w przypadku niespełnienia warunku. Służy do tego <code>else</code>:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>if (warunek) {\n    // gdy warunek true\n} else {\n    // gdy warunek false\n}</code></pre></div><p>Blok po <code>else</code> wykona się tylko wtedy, gdy warunek w <code>if</code> okaże się fałszywy. Dzięki temu mamy dwie ścieżki wykonania – jedną dla przypadku spełnienia warunku i drugą dla przypadku przeciwnego.</p><p>Przykład zastosowania <code>if/else</code>:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int temperatura = -5;\nif (temperatura &lt; 0) {\n    cout &lt;&lt; \"Jest mroz\";  // wykonane, gdy temperatura poniżej zera\n} else {\n    cout &lt;&lt; \"Temperatura powyżej zera\";  // wykonane, gdy temperatura >= 0\n}</code></pre></div><p>Dla <code>temperatura = -5</code> warunek <code>temperatura &lt; 0</code> jest prawdziwy, więc program wypisze „Jest mróz”.</p><h3>Else if</h3><p>Możemy łączyć wiele warunków sekwencyjnie za pomocą konstrukcji <code>else if</code>. Pozwala to sprawdzać kolejne warunki, gdy poprzednie okażą się fałszywe:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>if (warunek1) {\n    // gdy warunek1 true\n} else if (warunek2) {\n    // gdy warunek1 false, a warunek2 true\n} else if (warunek3) {\n    // gdy warunek1 i warunek2 false, a warunek3 true\n} else {\n    // gdy żaden z warunków nie był true\n}</code></pre></div><p>Program przechodzi przez kolejne warunki od góry. Gdy natrafi na pierwszy spełniony warunek, wykona odpowiedni blok kodu i pominie resztę (nie sprawdza dalszych warunków).</p><p>Przykład:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int liczba = 0;\nif (liczba &gt; 0) {\n    cout &lt;&lt; \"dodatnia\";\n} else if (liczba &lt; 0) {\n    cout &lt;&lt; \"ujemna\";\n} else {\n    cout &lt;&lt; \"zero\";\n}</code></pre></div><p>Ten fragment kodu sprawdza znak liczby całkowitej. Mamy trzy rozłączne warunki:</p><ul><li>jeśli <code>liczba &gt; 0</code> – wypisze „dodatnia”</li><li>w przeciwnym razie, jeśli <code>liczba &lt; 0</code> – wypisze „ujemna”</li><li>w przeciwnym razie (czyli liczba = 0) – wypisze „zero”</li></ul><p><strong>Uwaga:</strong> pojedyncza instrukcja po <code>if</code> lub <code>else</code> nie wymaga klamer, ale ich stosowanie jest zalecane. Można pisać też tak:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>if (x &gt; 0)\n    cout &lt;&lt; \"plus\";\nelse\n    cout &lt;&lt; \"nie plus\";</code></pre></div><p>Jednak brak klamer może być źródłem błędów przy dalszej rozbudowie kodu – dlatego dla przejrzystości zawsze warto używać <code>{ }</code>.</p><h3>Konwersja na bool</h3><p>Warunek w <code>if</code> oczekuje wartości logicznej. Jeśli przekażemy tam wartość liczbową, zostanie ona niejawnie skonwertowana: wartość zero to <code>false</code>, każda inna to <code>true</code>. Np.:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>if (x)  // sprawdza czy x != 0</code></pre></div><p>Zalecamy jednak jawnie pisać warunki dla lepszej czytelności, np. <code>if (x != 0)</code> zamiast <code>if (x)</code>.</p>"
          },
          {
            "id": 2,
            "title": "Instrukcja switch ... case",
            "content": "<p>Instrukcja <code>switch</code> stanowi wygodny sposób sprawdzania wartości zmiennej (najczęściej zmiennej liczbowej lub wyliczeniowej) względem wielu możliwych opcji. Można ją traktować jako alternatywę dla szeregu instrukcji <code>if ... else if</code>, gdy porównujemy tę samą zmienną do różnych stałych wartości.</p><p>Składnia jest następująca:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>switch (wyrazenie) {\n    case stala1:\n        // kod dla przypadku gdy wyrazenie == stala1\n        break;\n    case stala2:\n        // kod dla przypadku gdy wyrazenie == stala2\n        break;\n    ...\n    default:\n        // kod gdy żaden z powyższych przypadków nie pasuje\n}</code></pre></div><p><strong>Działanie:</strong> wyrażenie wewnątrz <code>switch</code> (w nawiasach) zostanie obliczone, a następnie jego wartość będzie kolejno porównywana do wartości w etykietach <code>case</code>. Gdy znajdzie się pasujący <code>case</code>, wykonanie programu przechodzi do tego miejsca i kontynuuje działanie.</p><p><strong>Ważne:</strong> Na końcu każdego przypadku zwykle umieszczamy instrukcję <code>break</code>, aby przerwać dalsze wykonywanie <code>switch</code>. Jeśli <code>break</code> pominiemy, kod <em>przeleci</em> przez kolejne <code>case</code>’y (tzw. <em>fall-through</em>), co w większości przypadków nie jest pożądane.</p><p>Etykieta <code>default</code> (opcjonalna) oznacza blok kodu, który zostanie wykonany, jeśli żadna z podanych etykiet <code>case</code> nie pasuje do wartości wyrażenia. Działa podobnie do finalnego <code>else</code> w <code>if/else</code>.</p><h3>Przykład zastosowania switch – prosty tekstowy program menu:</h3><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int wybor;\ncout &lt;&lt; \"Wybierz opcję: 1 - Nowa gra, 2 - Wczytaj grę, 3 - Wyjdź\\n\";\ncin &gt;&gt; wybor;\nswitch (wybor) {\n    case 1:\n        cout &lt;&lt; \"Uruchamianie nowej gry...\\n\";\n        break;\n    case 2:\n        cout &lt;&lt; \"Wczytywanie gry...\\n\";\n        break;\n    case 3:\n        cout &lt;&lt; \"Koniec programu.\\n\";\n        break;\n    default:\n        cout &lt;&lt; \"Nie ma takiej opcji!\\n\";\n}</code></pre></div><h3>Analiza:</h3><ul><li>Użytkownik wprowadza liczbę od 1 do 3 wybierając opcję. <code>switch</code> sprawdza zmienną <code>wybor</code>.</li><li>Gdy <code>wybor == 1</code>, wykonywany jest kod po <code>case 1</code>: wypisuje się komunikat o uruchomieniu gry i następuje <code>break</code>.</li><li>Dla <code>wybor == 2</code> wykonuje się <code>case 2</code> z odpowiednim komunikatem.</li><li>Dla <code>wybor == 3</code> wypisywana jest informacja o zakończeniu programu.</li><li>Jeśli wartość <code>wybor</code> nie pasuje do żadnego z <code>case</code>’ów (np. 0, 4, 99, znak), wykonany zostanie blok <code>default</code>.</li></ul><h3>Dlaczego break jest ważny?</h3><p>Jeśli w powyższym przykładzie zapomnimy np. <code>break</code> w <code>case 1</code>, to po wypisaniu „Uruchamianie nowej gry...” program <em>kontynuowałby wykonanie kolejnych case’ów</em> aż do napotkania <code>break</code> lub końca switcha. Może to prowadzić do niechcianych efektów i błędów logicznych.</p><h3>Zastosowanie switch:</h3><p>Switch sprawdza się głównie przy porównywaniu jednej zmiennej/wyrażenia do wielu stałych wartości. Należy pamiętać, że <code>case</code> muszą być stałymi (literały, stałe typu <code>enum</code>, definicje <code>#define</code>, <code>const</code> znane w czasie kompilacji) – nie mogą zależeć od zmiennych obliczanych w runtime.</p><p>Typ wyrażenia w <code>switch</code> najczęściej jest całkowity lub enumerowany. W nowoczesnym C++17 dopuszcza się też <code>std::string</code> i klasy z <code>constexpr</code>-porównaniem w czasie kompilacji, ale w C++11/14 nie można używać <code>switch</code> na napisach ani liczbach zmiennoprzecinkowych.</p>"
          }
        ]
      },
      {
        "id": 5,
        "title": "Instrukcje warunkowe",
        "description": "",
        "lessons": [
          {
            "id": 1,
            "title": "Pętla for",
            "content": "<p>Pętle umożliwiają powtarzanie fragmentu kodu wielokrotnie. Zacznijmy od najbardziej klasycznej pętli <code>for</code>, która jest często używana, gdy z góry znamy liczbę powtórzeń lub chcemy iterować po kolei po pewnym zakresie wartości.</p><p><strong>Składnia pętli for:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>for (inicjalizacja; warunek; aktualizacja) {\n    // blok instrukcji do powtarzania\n}</code></pre></div><p><strong>Działanie pętli <code>for</code>:</strong></p><ol><li>Wykonywana jest <strong>inicjalizacja</strong> – najczęściej deklaracja i ustawienie zmiennej sterującej pętlą (np. licznika).</li><li>Sprawdzany jest <strong>warunek</strong>. Jeśli warunek jest false od razu na starcie – pętla kończy działanie (blok nie zostanie wykonany ani razu). Jeśli warunek jest true – wchodzimy do bloku pętli.</li><li>Wykonywany jest blok instrukcji pętli.</li><li>Po wykonaniu bloku wykonywana jest <strong>aktualizacja</strong> – zwykle zmiana wartości licznika (np. inkrementacja).</li><li>Następnie ponownie sprawdzany jest warunek i cykl się powtarza dopóki warunek jest spełniony.</li></ol><p><strong>Typowy przykład: wypisanie liczb od 1 do 5:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>for (int i = 1; i &lt;= 5; ++i) {\n    cout &lt;&lt; i &lt;&lt; \" \";\n}</code></pre></div><p><strong>Wynik:</strong> Program wypisze: <code>1 2 3 4 5</code>.</p><h3>Analiza:</h3><ul><li><strong>Inicjalizacja:</strong> <code>int i = 1;</code> – tworzymy licznik <code>i</code> i ustawiamy go na 1.</li><li><strong>Warunek:</strong> <code>i &lt;= 5</code> – dopóki <code>i</code> jest mniejsze lub równe 5, iteracje będą kontynuowane.</li><li><strong>Aktualizacja:</strong> <code>++i</code> – po każdej iteracji zwiększamy <code>i</code> o 1 (preinkrementacja).</li><li><strong>Treść pętli:</strong> <code>cout &lt;&lt; i &lt;&lt; \" \";</code> – wypisujemy aktualną wartość <code>i</code> i spację.</li></ul><h3>Przebieg:</h3><ul><li>i = 1 (1 &lt;= 5 → true) → wypisz „1” → ++i (i = 2)</li><li>i = 2 (2 &lt;= 5 → true) → wypisz „2” → i = 3</li><li>i = 3 → wypisz „3” → i = 4</li><li>i = 4 → wypisz „4” → i = 5</li><li>i = 5 → wypisz „5” → i = 6</li><li>i = 6 → (6 &lt;= 5 → false) → warunek fałszywy, koniec pętli</li></ul><p>Widać, że pętla wykonała się 5 razy (dla i = 1, 2, 3, 4, 5). Po zakończeniu zmienna <code>i</code> ma wartość 6 (warto o tym pamiętać, jeśli używamy jej później – czasem po pętli stan licznika jest wykorzystany do dalszych obliczeń).</p><h3>Zastosowania pętli for:</h3><ul><li><strong>Iteracja w zadanym zakresie:</strong> np. przejście po elementach tablicy.</li><li><strong>Wykonywanie czegoś określoną ilość razy:</strong> np. 10-krotne pobranie danych od użytkownika.</li><li><strong>Tworzenie tablic, list wyników:</strong> np. generowanie tabelki wartości funkcji matematycznej co pewien krok.</li></ul><p>Pętlę <code>for</code> można skonstruować również bez niektórych elementów składniowych:</p><ul><li>Można pominąć <strong>inicjalizację</strong> w nawiasie <code>for</code>, jeśli zmienna jest przygotowana wcześniej.</li><li>Można pominąć <strong>aktualizację</strong> wewnątrz nawiasu <code>for</code> (np. aktualizować licznik na końcu bloku pętli manualnie).</li><li>Można nawet pominąć <strong>warunek</strong> – wtedy domyślnie traktowany jest jako <code>true</code>, czyli tworzymy pętlę nieskończoną, z której trzeba wyjść inaczej (np. <code>break</code>).</li></ul><p><strong>Przykład:</strong> <code>for (;;)</code> to nieskończona pętla for (ani inicjalizacji, ani warunku, ani aktualizacji). Takiej składni używa się jednak rzadko – zwykle bardziej czytelna jest nieskończona pętla <code>while(true)</code>.</p>"
          },
          {
            "id": 2,
            "title": "Pętla while i do...while",
            "content": "<p>Drugim rodzajem pętli jest <code>while</code> – ma nieco prostszą budowę i przydaje się, gdy nie wiadomo z góry ile razy pętla ma się wykonać (warunek jest sprawdzany za każdym razem przed wykonaniem bloku i typowo jakaś operacja wewnątrz pętli prowadzi do spełnienia warunku kończącego).</p><p><strong>Składnia pętli while:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>while (warunek) {\n    // blok kodu powtarzany dopóki warunek jest true\n}</code></pre></div><p><strong>Działanie:</strong> Dopóki warunek jest spełniony (<code>true</code>), dopóty wykonuj zawartość pętli. Warunek jest sprawdzany przed każdą iteracją (również przed pierwszą). Jeśli od razu na początku okaże się <code>false</code>, blok pętli nie wykona się ani razu.</p><p><strong>Przykład – użycie pętli while do osiągnięcia tego samego efektu co pętla for:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int j = 1;\nwhile (j &lt;= 5) {\n    cout &lt;&lt; j &lt;&lt; \" \";\n    j++; // musimy sami zadbać o zwiększenie licznika wewnątrz pętli\n}</code></pre></div><p>Ten kod również wypisze: <code>1 2 3 4 5</code>. Zaczynamy od <code>j = 1</code>. Sprawdzamy warunek (<code>1 &lt;= 5</code> → true) i wchodzimy do pętli – wypisujemy wartość i zwiększamy <code>j</code>. Następnie wracamy do sprawdzenia warunku z nowym <code>j</code>. Gdy <code>j</code> osiągnie 6, warunek będzie fałszywy i pętla zakończy działanie.</p><p><strong>Uwaga:</strong> W pętli <code>while</code> musimy pamiętać o zmianie zmiennych wpływających na warunek wewnątrz pętli, inaczej możemy utknąć w pętli nieskończonej. W powyższym przykładzie konieczne było ręczne <code>j++</code> wewnątrz pętli. Gdyby tego zabrakło, <code>j</code> zawsze byłoby 1 i warunek <code>j &lt;= 5</code> byłby zawsze prawdziwy – pętla działałaby w nieskończoność (dopóki ręcznie jej nie przerwiemy).</p><h3>Pętla nieskończona</h3><p>Czasami takie nieskończone pętle są zamierzone – np. program ma działać w nieskończonym cyklu obsługując jakieś zdarzenia dopóki użytkownik go nie zamknie. Wówczas stosujemy <code>while(true)</code> lub inną konstrukcję nieskończoną, a w środku używamy instrukcji <code>break</code> do przerwania pętli przy pewnym zdarzeniu.</p><h3>Pętla do...while</h3><p>Trzecią konstrukcją powtarzającą jest <code>do...while</code>, która różni się tym, że warunek sprawdzany jest po wykonaniu bloku. Gwarantuje to co najmniej jednokrotne wykonanie zawartości pętli, nawet jeśli warunek jest na początku fałszywy.</p><p><strong>Składnia:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>do {\n    // blok kodu\n} while (warunek);</code></pre></div><p>Zwróć uwagę na średnik <code>;</code> po warunku – jest wymagany w <code>do...while</code> (co odróżnia ją składniowo od zwykłego <code>while</code> na początku).</p><p><strong>Działanie:</strong> Najpierw wykona się blok w <code>{ }</code>, a dopiero potem sprawdzany jest <code>warunek</code>. Jeśli <code>warunek</code> jest true – pętla zatoczy kolejny cykl. Jeśli false – nastąpi wyjście z pętli.</p><p><strong>Przykład:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int k = 1;\ndo {\n    cout &lt;&lt; \"Iteracja nr \" &lt;&lt; k &lt;&lt; endl;\n    k++;\n} while (k &lt;= 3);</code></pre></div><p><strong>Wynik:</strong></p><pre><code>Iteracja nr 1\nIteracja nr 2\nIteracja nr 3</code></pre><p>Pętla wypisuje numer iteracji i zwiększa licznik, a następnie sprawdza czy <code>k &lt;= 3</code>. Pętla wykonała się 3 razy (dla k = 1, 2, 3). Gdy <code>k</code> zostało zwiększone do 4, warunek stał się fałszywy i pętla zakończyła działanie.</p><p>Gdyby w powyższym kodzie zmienna <code>k</code> początkowo wynosiła np. 10, to pętla <code>do...while</code> i tak wykonałaby się raz, bo sprawdzenie warunku nastąpiłoby dopiero po pierwszym wykonaniu bloku. W takim przypadku zadziałałaby jak pojedynczy blok kodu.</p><p>Dla porównania zwykła pętla <code>while(k &lt;= 3)</code> z <code>k = 10</code> nie wykonałaby się ani razu.</p><h3>Kiedy używać do...while?</h3><p>Stosujemy ją, gdy <em>co najmniej jedno wykonanie</em> pętli jest potrzebne bez względu na warunek. Przykładem może być ponawianie pytania do użytkownika do momentu otrzymania poprawnej odpowiedzi – najpierw i tak musimy zadać pytanie, potem sprawdzamy odpowiedź i ewentualnie pytamy ponownie. <code>do...while</code> nadaje się do tego znakomicie.</p>"
          },
          {
            "id": 3,
            "title": "Przerywanie i pomijanie iteracji: break i continue",
            "content": "<p><strong><code>break</code></strong> – instrukcja ta służy do natychmiastowego przerwania pętli. Po wykonaniu <code>break</code> następuje wyjście z najbardziej wewnętrznej pętli, w której się znajdujemy (program kontynuuje działanie za tą pętlą). Używamy <code>break</code>, gdy np. znaleźliśmy już to, czego szukaliśmy i dalsze iteracje nie są potrzebne, lub gdy wystąpił jakiś warunek wyjątkowy wymagający zakończenia powtarzania.</p><p><strong><code>continue</code></strong> – ta instrukcja powoduje przeskoczenie do następnej iteracji pętli (pomija dalsze wykonywanie bieżącej iteracji). Gdy <code>continue</code> zostanie wykonane, sterowanie przechodzi od razu do momentu sprawdzenia warunku pętli (oraz ew. do sekcji <code>aktualizacji</code> w przypadku pętli <code>for</code>), z pominięciem reszty instrukcji w bloku.</p><p><strong>Przykład użycia <code>break</code></strong> – znajdowanie pierwszej liczby większej od 100 w tablicy:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int arr[10] = {5, 20, 50, 130, 8, 45, 200, 1, 0, 14};\nfor (int i = 0; i &lt; 10; ++i) {\n    if (arr[i] &gt; 100) {\n        cout &lt;&lt; \"Znaleziono liczbę &gt;100: \" &lt;&lt; arr[i] &lt;&lt; endl;\n        break;\n    }\n}\ncout &lt;&lt; \"Koniec szukania.\\n\";</code></pre></div><p>Program przeszukuje kolejne elementy tablicy <code>arr</code>. Gdy trafi na element większy niż 100 (w przykładzie będzie to 130 przy <code>i=3</code>), wypisuje informację i wykonuje <code>break</code>, które przerywa pętlę <code>for</code> – dzięki czemu dalsze elementy nie będą już sprawdzane (nie ma takiej potrzeby, chcieliśmy znaleźć <em>pierwszy</em> pasujący element). Po pętli wypisujemy komunikat „Koniec szukania”.</p><p><strong>Przykład użycia <code>continue</code></strong> – wypisanie liczb od 1 do 10 pomijając te podzielne przez 3:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>for (int n = 1; n &lt;= 10; ++n) {\n    if (n % 3 == 0)\n        continue;  // pomiń liczby podzielne przez 3\n    cout &lt;&lt; n &lt;&lt; \" \";\n}</code></pre></div><p>Dla <code>n</code> równego 3, 6, 9 warunek <code>n % 3 == 0</code> będzie true, więc wykonane zostanie <code>continue</code>. Spowoduje to natychmiastowe przejście do kolejnej iteracji – czyli pominięcie instrukcji <code>cout &lt;&lt; n</code>; dla tych wartości nic nie zostanie wypisane.</p><p>W efekcie zostaną wypisane jedynie liczby: <code>1 2 4 5 7 8 10</code> (bez 3, 6, 9). Pętla nadal wykona pełnych 10 iteracji, ale trzy z nich nie doprowadzą do wywołania <code>cout</code> z powodu <code>continue</code>.</p><p><strong>Uwaga:</strong> Nadużywanie <code>break</code> i <code>continue</code> może czasem uczynić kod mniej czytelnym, ale w wielu sytuacjach poprawiają one przejrzystość (eliminując konieczność używania dodatkowych zagnieżdżonych <code>if</code>ów). Używaj ich z umiarem i zgodnie z intencją, a pętle staną się bardziej elastyczne.</p>"
          }
        ]
      },
      {
        "id": 6,
        "title": "Funkcje",
        "description": "",
        "lessons": [
          {
            "id": 1,
            "title": "Definiowanie i wywoływanie funkcji",
            "content": "<p>W większych programach korzystnie jest dzielić kod na mniejsze fragmenty realizujące określone zadania. Funkcje (ang. <em>functions</em>, w kontekście obiektowym zwane też metodami) to właśnie wydzielone podprogramy, które można wielokrotnie wywoływać w różnych miejscach kodu. C++ przejął składnię funkcji z języka C.</p><h3>Składnia definicji funkcji:</h3><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>typ_zwrotny nazwa_funkcji(parametry) {\n    // instrukcje składające się na ciało funkcji\n    return wyrażenie; // (opcjonalnie, zależy od typu_zwrotnego)\n}</code></pre></div><ul><li><code>typ_zwrotny</code> – typ wartości, którą funkcja zwraca jako wynik. Jeśli funkcja nic nie zwraca, używamy słowa kluczowego <code>void</code>.</li><li><code>nazwa_funkcji</code> – dowolna nazwa identyfikująca funkcję (te same zasady nazewnictwa jak dla zmiennych).</li><li><code>parametry</code> – lista parametrów wejściowych funkcji. Każdy parametr to para: typ oraz nazwa (np. <code>int a, double b</code>). Parametry zachowują się jak zmienne lokalne wewnątrz funkcji, inicjalizowane wartościami przekazanymi podczas wywołania. Jeśli funkcja nie przyjmuje żadnych argumentów, można napisać <code>(void)</code> – pustą listę.</li><li><code>return</code> – instrukcja zwracająca wartość z funkcji. Pojawia się tylko jeśli <code>typ_zwrotny</code> jest inny niż <code>void</code>. Wyrażenie po <code>return</code> musi być zgodne z typem zwrotnym. Powoduje natychmiastowe zakończenie wykonywania funkcji i przekazanie wyniku.</li></ul><h3>Przykład funkcji dodającej dwie liczby całkowite:</h3><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int dodaj(int x, int y) {\n    int suma = x + y;\n    return suma;\n}\n\n// ...\nint wynik = dodaj(3, 4);\ncout &lt;&lt; \"3 + 4 = \" &lt;&lt; wynik &lt;&lt; endl;</code></pre></div><h3>Analiza:</h3><ul><li>wartość 3 zostaje przypisana do parametru <code>x</code></li><li>wartość 4 zostaje przypisana do parametru <code>y</code></li><li>następnie wykonuje się ciało funkcji: obliczenie sumy i <code>return</code></li><li>funkcja zwraca wartość 7 do miejsca wywołania – zastępuje to wywołanie w wyrażeniu</li><li>można przypisać wartość do zmiennej lub użyć od razu</li><li>po zakończeniu funkcji następuje powrót do następnej instrukcji w kontekście głównym (np. <code>main</code>)</li></ul><p><strong>Wynik działania:</strong> <code>3 + 4 = 7</code></p><h3>Parametry i argumenty:</h3><p>W definicji funkcji mówimy o <em>parametrach formalnych</em> (<code>x</code> i <code>y</code>), a przy wywołaniu – <em>argumentach aktualnych</em> (3 i 4). Kompilator sprawdza zgodność typów i ilości argumentów. Jeśli coś się nie zgadza – wystąpi błąd kompilacji lub nieoczekiwany wynik.</p><h3>Funkcje typu void:</h3><p>Nie zawsze musimy coś zwracać. Możemy zdefiniować funkcję, która wykonuje tylko działanie np. wypisanie tekstu:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>void powitanie(string imie) {\n    cout &lt;&lt; \"Witaj, \" &lt;&lt; imie &lt;&lt; \"!\\n\";\n}\n\n// wywołanie:\npowitanie(\"Anna\");</code></pre></div><p><code>powitanie</code> przyjmuje jeden parametr typu <code>string</code> i nic nie zwraca. Nie ma potrzeby pisać <code>return</code>, choć można to zrobić by zakończyć wykonanie funkcji wcześniej.</p><h3>Zmienna lokalna:</h3><p>Zmienna <code>suma</code> wewnątrz funkcji <code>dodaj</code> istnieje tylko w czasie działania tej funkcji. Po zakończeniu funkcji znika z pamięci. Każde wywołanie funkcji tworzy nową instancję takich zmiennych lokalnych.</p><h3>Prototypy funkcji:</h3><p>W C++ kolejność definicji ma znaczenie – funkcja musi być znana przed jej użyciem. Jeśli chcemy wywołać funkcję np. w <code>main</code> zanim została zdefiniowana, musimy zadeklarować ją wcześniej poprzez <em>prototyp</em>:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int dodaj(int x, int y);  // prototyp\n\nint main() {\n    cout &lt;&lt; dodaj(2, 3);\n    return 0;\n}\n\nint dodaj(int x, int y) {\n    return x + y;\n}</code></pre></div><p>Dzięki prototypowi kompilator wie, że funkcja <code>dodaj</code> istnieje i jakich parametrów się spodziewać. Alternatywnie, możemy po prostu zdefiniować funkcję przed <code>main</code>.</p>"
          },
          {
            "id": 2,
            "title": "Parametry funkcji: przez wartość vs. przez referencję",
            "content": "<p>Domyślnie parametry w C++ są przekazywane do funkcji <strong>przez wartość</strong>. Oznacza to, że do funkcji trafiają <em>kopie</em> przekazanych argumentów. Zmiana parametru wewnątrz funkcji nie wpływa na zmienną z argumentem zewnętrznym.</p><p><strong>Przykład:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>void zwieksz_o_jeden(int x) {\n    x = x + 1;\n    cout &lt;&lt; \"Wewnątrz funkcji x = \" &lt;&lt; x &lt;&lt; endl;\n}\n\nint a = 5;\nzwieksz_o_jeden(a);\ncout &lt;&lt; \"Po funkcji a = \" &lt;&lt; a &lt;&lt; endl;</code></pre></div><p><strong>Wynik:</strong></p><pre><code>Wewnątrz funkcji x = 6\nPo funkcji a = 5</code></pre><p>Mimo, że wewnątrz funkcji <code>zwieksz_o_jeden</code> zmienna <code>x</code> (kopiująca wartość <code>a</code>) została zwiększona do 6, po powrocie wartość <code>a</code> na zewnątrz pozostała 5. To dlatego, że modyfikowaliśmy tylko lokalną kopię.</p><p>Przekazywanie przez wartość chroni argumenty przed niezamierzonym zmienianiem ich przez funkcję, ale czasem właśnie <em>chcemy</em> zmienić oryginał.</p><h3>Przez referencję:</h3><p>W C++ możemy zadeklarować parametr jako referencję, dodając znak <code>&</code> po typie. Referencja jest aliasem oryginalnej zmiennej. Przykład funkcji zamieniającej wartości dwóch zmiennych (tzw. swap):</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>void zamien(int &a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint x = 10, y = 20;\nzamien(x, y);\ncout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; \", y=\" &lt;&lt; y &lt;&lt; endl;  // wypisze x=20, y=10</code></pre></div><p>Parametry <code>a</code> i <code>b</code> są referencjami do zmiennych przekazanych. W momencie wywołania <code>zamien(x, y)</code>, <code>a</code> staje się aliasem zmiennej <code>x</code>, <code>b</code> aliasem <code>y</code>. Funkcja zamienia ich wartości, więc po powrocie <code>x</code> i <code>y</code> mają pozamieniane wartości – bez potrzeby zwracania czegokolwiek.</p><h3>Przez wskaźnik:</h3><p>Alternatywnie można przekazać adresy zmiennych do funkcji. Parametry wtedy będą wskaźnikami (np. <code>int*</code>). Funkcja <code>swap</code> z użyciem wskaźników wyglądałaby tak:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>void zamien_wsk(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// wywołanie:\nzamien_wsk(&x, &y);</code></pre></div><p>Przy wywołaniu używamy operatora <code>&</code>, by pobrać adresy zmiennych. Wewnątrz funkcji <code>*a</code>, <code>*b</code> oznaczają dostęp do wartości pod tymi adresami. Efekt działania identyczny – zamiana wartości.</p><p><strong>Uwaga:</strong> Referencje są bezpieczniejsze (nie mogą być nullami) i wygodniejsze. Częściej stosuje się je do parametrów wyjściowych. Wskaźniki są jednak bardziej uniwersalne – niezbędne np. w pracy z dynamiczną pamięcią.</p><h3>Zwracanie wartości:</h3><p>Funkcja może zwracać wartość, która najczęściej jest rezultatem obliczeń. Zwrot następuje przez <code>return</code>. Warto pamiętać:</p><ul><li>Zwrot następuje kopią (chyba że zwracamy referencję/wskaźnik).</li><li>Nowoczesne kompilatory stosują RVO (return value optimization), by unikać niepotrzebnych kopii.</li><li>W każdej ścieżce wykonania funkcji zwracającej coś musi istnieć <code>return</code> z odpowiednią wartością.</li><li>Funkcja <code>main()</code> też zwraca <code>int</code>. Zwykle <code>return 0;</code> oznacza sukces. Jeśli nic nie zwróci – <code>0</code> jest domyślne.</li></ul><h3>Funkcje przeciążone:</h3><p>C++ pozwala na przeciążanie funkcji – definiowanie wielu funkcji o tej samej nazwie, różniących się listą parametrów (liczbą lub typami). Kompilator wybiera właściwą wersję na podstawie argumentów. Przykład:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int pole(int a) { return a * a; }           // pole kwadratu o boku a\nint pole(int a, int b) { return a * b; }   // pole prostokąta a*b\ndouble pole(double r) { return 3.14 * r * r; } // pole koła</code></pre></div><p>Wywołanie <code>pole(5)</code> wybierze 1. wersję, <code>pole(3,4)</code> – drugą, <code>pole(2.5)</code> – trzecią. Przeciążanie to przykład <strong>polimorfizmu ad-hoc</strong> (statycznego) – ta sama nazwa działa dla różnych typów danych.</p>"
          }
        ]
      },
      {
        "id": 7,
        "title": "Tablice",
        "description": "",
        "lessons": [
          {
            "id": 1,
            "title": "Tablice jednowymiarowe",
            "content": "<p><strong>Tablica</strong> to zbiór wielu wartości <em>tego samego typu</em>, ułożonych kolejno w pamięci, do których odwołujemy się za pomocą wspólnej nazwy i indeksu. Tablice pozwalają przechować np. listę 100 liczb w pojedynczej strukturze, zamiast tworzyć 100 osobnych zmiennych.</p><p>W C++ tablice można definiować na dwa sposoby:</p><ul><li><strong>Tablice statyczne</strong> (o stałym rozmiarze) – klasyczna konstrukcja z języka C. Rozmiar tablicy musi być znany w czasie kompilacji (stała, np. literał, <code>#define</code>, <code>const</code>).</li><li><strong>Tablice dynamiczne</strong> – przydzielane z dynamicznej pamięci (omówimy w module o wskaźnikach) lub za pomocą kontenerów bibliotecznych (np. <code>std::vector</code> z biblioteki STL). Dają elastyczność zmiennego rozmiaru, ale wymagają dodatkowej obsługi (np. zwalniania pamięci).</li></ul><p>Na początek skupimy się na tablicach statycznych.</p><h3>Deklaracja tablicy:</h3><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>typ nazwa[rozmiar];</code></pre></div><p>To tworzy tablicę o podanym rozmiarze (liczba elementów). Elementy indeksowane są od <code>0</code> do <code>rozmiar-1</code>.</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int liczby[5];</code></pre></div><p>Tworzy tablicę <code>liczby</code> mogącą przechować 5 elementów typu <code>int</code>: <code>liczby[0]</code>, <code>liczby[1]</code>, ..., <code>liczby[4]</code>.</p><h3>Inicjalizacja tablicy:</h3><p>Można przypisać wartości tablicy podczas deklaracji używając listy wartości w <code>{}</code>:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int dni[7] = {1, 2, 3, 4, 5, 6, 7};</code></pre></div><p>Jeśli liczba wartości w <code>{}</code> jest mniejsza niż rozmiar tablicy – pozostałe elementy zostaną zainicjalizowane na 0:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int t[5] = {10, 20}; // t[0]=10, t[1]=20, t[2]=0, t[3]=0, t[4]=0</code></pre></div><p>Jeśli podamy dokładnie tyle elementów ile rozmiar – możemy pominąć jego deklarację, a kompilator go wywnioskuje:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int fib[] = {1, 1, 2, 3, 5, 8, 13}; // rozmiar = 7</code></pre></div><h3>Dostęp do elementów:</h3><p>Używamy indeksów w nawiasach kwadratowych:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int A[3] = {10, 20, 30};\ncout << A[0]; // wypisze 10\nA[1] = 50;    // zmienia 20 na 50\ncout << A[1]; // wypisze 50</code></pre></div><p><strong>Uwaga:</strong> C++ <em>nie sprawdza poprawności indeksów</em> w czasie działania! Jeśli napiszemy <code>A[3] = 5;</code> dla tablicy <code>A[3]</code>, to operujemy <em>poza tablicą</em> – to błąd, który może prowadzić do nieprzewidywalnych zachowań (nadpisanie pamięci, awaria programu itp.). Programista musi sam pilnować poprawnych indeksów w zakresie <code>0</code> do <code>rozmiar-1</code>.</p><h3>Iteracja po tablicy:</h3><p>Najczęściej używamy pętli (for, while), by przejść przez wszystkie elementy tablicy.</p><p><strong>Przykład – sumowanie elementów:</strong></p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int B[5] = {2, 4, 6, 8, 10};\nint suma = 0;\nfor (int i = 0; i < 5; ++i) {\n    suma += B[i];\n}\ncout << \"Suma = \" << suma << endl; // Suma = 30</code></pre></div><h3>Przykład praktyczny:</h3><p>Obliczenie średniej z pomiarów zapisanych w tablicy:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int pomiary[4] = {10, 15, 12, 8};\nint sum = 0;\nfor (int i = 0; i < 4; ++i) {\n    sum += pomiary[i];\n}\ndouble srednia = sum / 4.0;\ncout << \"Średnia = \" << srednia << endl; // Średnia = 11.25</code></pre></div><p>Dzięki użyciu <code>4.0</code> wymuszamy dzielenie zmiennoprzecinkowe, a wynik będzie typu <code>double</code>.</p>"
          },
          {
            "id": 2,
            "title": "Tablice wielowymiarowe",
            "content": "<p><strong>Tablice mogą mieć więcej niż jeden wymiar.</strong> Na przykład <em>tablica dwuwymiarowa</em> może być postrzegana jako tablica tablic – np. macierz w matematyce.</p><p>Deklaracja 2-wymiarowej tablicy wygląda tak:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>typ nazwa[rozmiar1][rozmiar2];</code></pre></div><p>Przykład:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int macierz[2][3];</code></pre></div><p>Tworzy tablicę 2×3 (2 wiersze, 3 kolumny) zdolną pomieścić 6 elementów typu <code>int</code>. Indeksy możemy interpretować jako <code>macierz[wiersz][kolumna]</code>, gdzie <code>wiersz ∈ {0,1}</code>, <code>kolumna ∈ {0,1,2}</code>.</p><h3>Inicjalizacja tablicy wielowymiarowej</h3><p>Można używać zagnieżdżonych klamr:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int M[2][3] = {\n    {1, 2, 3},\n    {4, 5, 6}\n};</code></pre></div><p>Powyżej <code>M</code> jest tablicą 2x3. Pierwszy wiersz to {1, 2, 3}, drugi {4, 5, 6}. Dostęp do elementu np. w drugim wierszu, trzeciej kolumnie: <code>M[1][2]</code> (indeksy liczymy od 0 – 1 oznacza drugi wiersz, 2 trzecią kolumnę). <code>M[1][2]</code> w tym przypadku ma wartość 6.</p><h3>Iteracja po tablicy 2D</h3><p>Najczęściej realizuje się za pomocą pętli zagnieżdżonych:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < 3; ++j) {\n        cout << M[i][j] << \" \";\n    }\n    cout << endl;\n}</code></pre></div><p><strong>Wynik:</strong></p><pre><code>1 2 3\n4 5 6</code></pre><p>Pętla zewnętrzna <code>i</code> wybiera wiersz (0, potem 1). Pętla wewnętrzna <code>j</code> iteruje kolumny od 0 do 2, wypisując kolejne elementy w danym wierszu. Po zakończeniu pętli wewnętrznej (czyli po wypisaniu całego wiersza) wypisujemy znak nowej linii <code>endl</code>.</p><h3>Więcej wymiarów</h3><p>Możliwe są też tablice trzy- i więcej-wymiarowe, np.</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>int trojwymiar[3][4][5];</code></pre></div><p>– interpretacja jako prostokątna \"bryła\" elementów. W praktyce jednak rzadko korzysta się z tablic powyżej 3 wymiarów bez specjalnej potrzeby.</p><h3>Tablice a pamięć</h3><p>Tablice statyczne deklarowane jak powyżej mogą być tworzone:</p><ul><li>jako zmienne lokalne funkcji (na stosie programu) – wtedy ich rozmiar nie powinien być zbyt duży, bo stos jest ograniczony,</li><li>jako zmienne globalne / statyczne (w tzw. segmencie statycznym pamięci),</li><li>ewentualnie wewnątrz struktury/klasy jako jej pole.</li></ul><p>Jeśli potrzebujemy bardzo dużej tablicy lub takiej, której rozmiar zależy od danych wejściowych (czyli nieznany na etapie kompilacji), używamy <strong>alokacji dynamicznej</strong> (omówionej później).</p><h3>String a tablica char</h3><p>Wspomnieliśmy wcześniej o typie <code>std::string</code>. W starszym C ciągi znaków reprezentowane były jako tablice <code>char</code> zakończone znakiem <code>'\\0'</code>.</p><p>Przykład:</p><div style='background:#f4f4f4;padding:1rem;border-radius:6px;margin:1rem 0;'><pre><code>char napis[6] = \"Ala\";</code></pre></div><p>Tworzy tablicę długości 6 (musi pomieścić znaki <code>'A'</code>, <code>'l'</code>, <code>'a'</code>, <code>'\\0'</code> i ewentualnie więcej).</p><p>W C++ nadal można używać tablic znakowych, ale ich obsługa jest bardziej złożona (np. <code>&lt;cstring&gt;</code> do konkatenacji, kopiowania itp.). W praktyce preferuje się <code>std::string</code>, który automatycznie zarządza tablicą i upraszcza wiele operacji.</p><p><strong>Uwaga:</strong> Przypisanie do <code>char</code> odbywa się przez apostrofy, np. <code>'A'</code>, do <code>std::string</code> – przez cudzysłów: <code>\"tekst\"</code>.</p><p>Można też przypisać do <code>char*</code> lub używać w inicjalizacji tablicy <code>char</code>. Do <code>std::string</code> można przypisać literal wprost (ma zaimplementowaną konwersję).</p>"
          }
        ]
      }
    ],
    "quiz": {
      "questions": [
        {
          "id": 1,
          "question": "Która deklaracja funkcji main w C++ jest poprawna?",
          "answers": [
            "int main() { ... }",
            "void main() { ... }",
            "Main() { ... }",
            "public static void main() { ... }"
          ],
          "correct": [0],
          "points": 1
        },
        {
          "id": 2,
          "question": "Jaki typ zmiennej należy użyć do przechowywania wartości logicznych (prawda/fałsz)?",
          "answers": [
            "bool",
            "char",
            "int",
            "float"
          ],
          "correct": [0],
          "points": 1
        },
        {
          "id": 3,
          "question": "Załóżmy: int x = 5, y = 2;. Jaki będzie wynik wykonania instrukcji cout << x / y;?",
          "answers": [
            "2",
            "2.5",
            "2.0",
            "spowoduje błąd w czasie wykonywania"
          ],
          "correct": [0],
          "points": 1
        },
        {
          "id": 4,
          "question": "Co wypisze poniższy kod?\n\nint a = 10;\nif(a < 5)\n   cout << \"malo\";\nelse\n   cout << \"duzo\";",
          "answers": [
            "malo",
            "duzo",
            "nie wypisze nic",
            "malo i duzo (obie opcje)"
          ],
          "correct": [1],
          "points": 1
        },
        {
          "id": 5,
          "question": "Które słowo kluczowe służy do zakończenia case’a w instrukcji switch, zapobiegając tzw. \"przechodzeniu\" (fall-through)?",
          "answers": [
            "break",
            "continue",
            "exit",
            "stop"
          ],
          "correct": [0],
          "points": 1
        },
        {
          "id": 6,
          "question": "Co wypisze ten fragment kodu?\n\nfor(int i = 0; i < 3; i++) {\n   cout << i;\n}",
          "answers": [
            "012",
            "123",
            "0123",
            "0 1 2 (z odstępami)"
          ],
          "correct": [0],
          "points": 1
        },
        {
          "id": 7,
          "question": "Co oznacza słowo kluczowe void przy deklaracji funkcji?",
          "answers": [
            "Funkcja nie zwraca żadnej wartości.",
            "Funkcja nie przyjmuje żadnych argumentów.",
            "Funkcja jest wykonywana w tle (wątek).",
            "To słowo kluczowe nie ma specjalnego znaczenia."
          ],
          "correct": [0],
          "points": 1
        },
        {
          "id": 8,
          "question": "Dany jest fragment: int arr[3] = {5,6,7};. Jaka jest wartość arr[1]?",
          "answers": [
            "5",
            "6",
            "7",
            "niezdefiniowana (błąd)"
          ],
          "correct": [1],
          "points": 1
        },
        {
          "id": 9,
          "question": "Jakie są poprawne typy pętli w C++? (zaznacz wszystkie poprawne)",
          "answers": [
            "for",
            "foreach",
            "while",
            "do...while"
          ],
          "correct": [0, 2, 3],
          "points": 2
        },
        {
          "id": 10,
          "question": "Które z poniższych są poprawnymi identyfikatorami w C++?",
          "answers": [
            "_zmienna1",
            "2xStart",
            "liczba$",
            "totalSum"
          ],
          "correct": [0, 3],
          "points": 2
        },
        {
          "id": 11,
          "question": "Co wypisze kod: int t[] = {1, 2, 3}; cout << t[3]; ?",
          "answers": [
            "1",
            "3",
            "Nie wiadomo – błąd poza zakresem (undefined behavior)",
            "0"
          ],
          "correct": [2],
          "points": 1
        },
        {
          "id": 12,
          "question": "Wskaż poprawną deklarację tablicy 10 elementowej typu int:",
          "answers": [
            "int tablica[10];",
            "int tablica(10);",
            "array<int> tablica[10];",
            "int tablica = new int[10];"
          ],
          "correct": [0],
          "points": 1
        },
        {
          "id": 13,
          "question": "Które operatory służą do inkrementacji i dekrementacji?",
          "answers": [
            "++ i --",
            "** i //",
            "+=1 i -=1",
            "++ i **"
          ],
          "correct": [0],
          "points": 1
        }
      ]
    }
  },

  {
    "id": 2,
    "title": "Python od podstaw",
    "image": "/images/Python.png",
    "duration": "1-2 godzin",
    "category": "Programowanie",
    "categoryGroup": "programowanie",
    "welcomeMessage": "Witaj w kursie! Dzięki temu kursowi nauczysz się podstaw języka Python. Zaczniemy od instalacji środowiska i podstawowych zmiennych, a następnie przejdziemy do bardziej zaawansowanych tematów, takich jak funkcje, pętle i obsługa wyjątków.",
    "objectives": [
      "Zrozumieć podstawy języka Python",
      "Nauczyć się pracy z zmiennymi, typami danych, oraz operatorami",
      "Poznać podstawy programowania obiektowego",
      "Opanować pracę z pętlami i warunkami",
      "Tworzyć funkcje oraz operować na plikach"
    ],
    "modules": [
      {
         "id": 1,
         "title": "Wprowadzenie do Pythona",
         "description": "Nauczysz się, jak zainstalować i skonfigurować Pythona oraz jak uruchomić pierwszy program.",
         "lessons": [
          {
            "id": 1,
            "title": "Instalacja Pythona i pierwsze kroki",
            "content": "<h2>Wstęp do Pythona</h2><p>Python to jeden z najpopularniejszych języków programowania, wykorzystywany w wielu dziedzinach, takich jak tworzenie stron internetowych, analiza danych, sztuczna inteligencja czy automatyzacja. W tej lekcji nauczysz się, jak zainstalować Pythona na swoim komputerze oraz jak uruchomić swój pierwszy program, co jest pierwszym krokiem do rozpoczęcia nauki programowania.</p><h3>1. Instalacja Pythona</h3><p>Aby rozpocząć pracę z Pythonem, musisz go najpierw zainstalować na swoim komputerze. Oto jak to zrobić:</p><ul><li><strong>Przejdź na stronę <a href='https://www.python.org/downloads/' target='_blank'>python.org</a> i pobierz najnowszą wersję Pythona.</strong></li><li><strong>Wybierz wersję odpowiednią do systemu operacyjnego (Windows, macOS, Linux) i zainstaluj ją.</strong> Pamiętaj, aby podczas instalacji zaznaczyć opcję „Add Python to PATH”, co umożliwi uruchamianie Pythona z poziomu terminala.</li><li><strong>Po zakończeniu instalacji otwórz terminal (w systemie Windows PowerShell lub Command Prompt, a na macOS/Linux terminal) i sprawdź, czy Python został poprawnie zainstalowany:</strong></li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>python --version</pre><p>Powinieneś zobaczyć wynik podobny do:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>Python 3.x.x</pre><h3>2. Twój pierwszy program w Pythonie</h3><p>Czas na napisanie swojego pierwszego programu! Otwórz edytor tekstu (np. Notepad na Windowsie, Sublime Text, VSCode) i stwórz plik o nazwie <strong>pierwszy_program.py</strong>. Wpisz poniższy kod:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>print('Hello, World!')</pre><p>Zapisz plik, a następnie uruchom go z poziomu terminala:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>python pierwszy_program.py</pre><p>Po wykonaniu tego polecenia na ekranie powinno pojawić się:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>Hello, World!</pre><h3>3. Korzystanie z interaktywnego środowiska (REPL)</h3><p>Python oferuje także interaktywne środowisko, które umożliwia testowanie kodu w czasie rzeczywistym. Aby to zrobić, wystarczy w terminalu wpisać:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>python</pre><p>Po wejściu do trybu interaktywnego możesz od razu zacząć pisać kod. Przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>>>&nbsp;print('Witaj w Pythonie!')</pre><p>Wynik to:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>Witaj w Pythonie!</pre><h3>4. Komentarze i podstawowe zasady składni</h3><p>W Pythonie nie musisz dodawać średników na końcu linii, a komentarze zaczynają się od znaku <code>#</code>. Przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'># To jest komentarz</pre><p>Komentarze są ignorowane przez komputer, więc są użyteczne do dokumentowania kodu lub wyłączania części kodu, które na razie nie są potrzebne.</p><h3>5. Co dalej?</h3><p>Teraz, gdy masz Pythona zainstalowanego i uruchomiłeś swój pierwszy program, możesz przejść do bardziej zaawansowanych zagadnień, takich jak zmienne, funkcje, pętle i struktury danych. Zaczniemy od tego w kolejnych lekcjach!</p><p><strong>"
          },
          
          {
            "id": 2,
            "title": "Pierwszy program w Pythonie",
            "content": "<br>W tej lekcji stworzymy program, który pozwoli użytkownikowi na podanie swojego imienia i wieku, a następnie powita go w Pythonie, wyświetlając odpowiedni komunikat. Ten program pomoże ci zrozumieć, jak działa wprowadzanie danych oraz jak używać zmiennych w Pythonie.</p><h3>1. Tworzymy program</h3><p>Otwórz swój edytor tekstu (np. Notepad, Sublime Text, VSCode) i stwórz nowy plik o nazwie <strong>powitanie.py</strong>. Wpisz poniższy kod:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'># Program wita użytkownika<br># Pobieramy dane od użytkownika<br>imie = input(&quot;Jak masz na imię? &quot;)<br>wiek = input(&quot;Ile masz lat? &quot;)<br><br># Wypisujemy powitanie<br>print(f&quot;Cześć {imie}! Masz {wiek} lat, witaj w Pythonie!&quot;)</pre><h3>2. Co robi ten program?</h3><p>1. <strong>Pobiera dane od użytkownika:</strong> Program używa funkcji <code>input()</code>, która umożliwia użytkownikowi wpisanie tekstu w terminalu. Wartość, którą użytkownik wpisuje, jest zapisywana w zmiennych <code>imie</code> i <code>wiek</code>.<br><br>2. <strong>Wyświetla komunikat:</strong> Program wykorzystuje funkcję <code>print()</code>, aby wypisać na ekranie komunikat powitalny, który zawiera imię i wiek użytkownika. Zastosowanie f-stringa (<code>f&quot;tekst {zmienna}&quot;</code>) umożliwia łatwe wstawienie zmiennych do tekstu.</p><h3>3. Uruchamiamy program</h3><p>Zapisz plik i uruchom go z poziomu terminala. Przejdź do folderu, w którym zapisałeś plik i wpisz:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>python powitanie.py</pre><p>Po uruchomieniu programu terminal poprosi cię o podanie swojego imienia i wieku.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #99bbff;overflow-x:auto;'>Jak masz na imię? Anna<br>Ile masz lat? 25<br>Cześć Anna! Masz 25 lat, witaj w Pythonie!</pre><h3>4. Co się stało?</h3><p>Program najpierw poprosił cię o wpisanie swojego imienia i wieku. Następnie te informacje zostały zapisane w zmiennych, a funkcja <code>print()</code> wyświetliła je na ekranie w powitalnym komunikacie.</p><h3>5. Co dalej?</h3><p>Dzięki temu programowi nauczyłeś się, jak pobierać dane od użytkownika, przechowywać je w zmiennych oraz wyświetlać je na ekranie. W następnych lekcjach będziemy poznawać inne typy danych (np. liczby, które będą używane do obliczeń) oraz jak manipulować danymi w programie.</p><h2>Podsumowanie</h2><p>W tej lekcji stworzyliśmy prosty program, który zbiera dane od użytkownika i używa zmiennych do ich przechowywania. Takie programy są podstawą każdego języka programowania i stanowią fundament do bardziej zaawansowanych projektów.</p><h3>"
          }
          
        ]
      },
      {
        "id": 2,
        "title": "Zmienna, typy danych i operatory",
        "description": "Nauczysz się pracy z podstawowymi typami danych i operatorami w Pythonie.",
        "lessons": [
          {
            "id": 1,
            "title": "Zmienne i typy danych",
            "content": "</strong>W tej lekcji dowiesz się, czym są <strong>zmienne</strong>, jakie istnieją podstawowe <strong>typy danych</strong> w Pythonie, oraz jak używać <strong>operatorów</strong> do manipulacji tymi danymi. Zrozumienie tych podstawowych elementów jest kluczowe do tworzenia bardziej zaawansowanych programów.<br><br><h3>1. Zmienne w Pythonie</h3><p>Zmienne to miejsca w pamięci, które przechowują wartości. W Pythonie nie musisz określać typu zmiennej z góry, ponieważ Python sam dopasowuje typ do przypisanej wartości.</p><p><strong>Przykład:</strong></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>imie = \"Anna\"        # Zmienna przechowująca tekst<br>wiek = 25            # Zmienna przechowująca liczbę całkowitą</pre><p><strong>Opis:</strong><br><br>W powyższym przykładzie:<br>- <code>imie</code> jest zmienną typu <code>str</code> (tekst),<br>- <code>wiek</code> jest zmienną typu <code>int</code> (liczba całkowita).</p><p>Zmiennym możesz przypisać dowolne wartości, a Python sam zdecyduje o ich typie w zależności od przypisanej wartości.</p><br><h3>2. Typy Danych</h3><p>Python obsługuje różne typy danych, a najczęściej używane to:</p><ul><li><strong>int</strong> – liczby całkowite (np. 5, -3, 100)</li><li><strong>float</strong> – liczby zmiennoprzecinkowe (np. 3.14, -0.001, 2.0)</li><li><strong>str</strong> – łańcuchy tekstowe (np. \"Hello\", \"Python\")</li><li><strong>bool</strong> – wartości logiczne (True, False)</li></ul><p><strong>Przykłady:</strong></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>wiek = 25            # int<br>temperatura = 36.6   # float<br>imie = \"Anna\"        # str<br>czy_dorosly = True   # bool</pre><p>Każdy z tych typów ma swoje specyficzne cechy. Przykładowo, zmienne typu <code>int</code> są używane do przechowywania liczb całkowitych, a zmienne typu <code>str</code> do przechowywania tekstu.</p><br><h3>3. Operatory w Pythonie</h3><p>Python oferuje kilka typów operatorów, które pomagają w operacjach na danych. Najczęściej używane to:</p><ul><li><strong>Operatory arytmetyczne</strong> (do wykonywania obliczeń): <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code></li><li><strong>Operatory porównania</strong> (do porównywania wartości): <code>==</code>, <code>!=</code>, <code>></code>, <code><</code>, <code>>=</code>, <code><=</code></li><li><strong>Operatory logiczne</strong> (do operacji na wartościach logicznych): <code>and</code>, <code>or</code>, <code>not</code></li></ul><p><strong>Przykład użycia operatorów arytmetycznych:</strong></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>a = 10<br>b = 3<br>suma = a + b        # Dodawanie<br>roznica = a - b     # Odejmowanie<br>iloraz = a / b      # Dzielenie (float)</pre><p><strong>Przykład użycia operatorów porównania:</strong></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>x = 5<br>y = 10<br>result = x < y      # True, ponieważ 5 jest mniejsze od 10</pre><p><strong>Przykład użycia operatorów logicznych:</strong></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>a = True<br>b = False<br>result = a and b    # False, ponieważ oba warunki muszą być True</pre><br><h3>4. Typy Zmiennych w Akcji</h3><p>Możesz używać zmiennych w różnych operacjach, na przykład włączać je do wyrażeń lub łączyć je z innymi typami.</p><p><strong>Przykład:</strong></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>imie = \"Anna\"<br>wiek = 25<br>powitanie = \"Cześć \" + imie + \", masz \" + str(wiek) + \" lat.\"<br>print(powitanie)</pre><p>W powyższym przykładzie używamy zmiennych typu <code>str</code> i <code>int</code> razem. Zauważ, że musieliśmy przekonwertować zmienną <code>wiek</code> na ciąg tekstowy, aby połączyć ją z innym tekstem.</p><br><h3>5. Podsumowanie</h3><p>- <strong>Zmienne</strong> w Pythonie są elastyczne, nie musisz określać ich typu z góry.<br>- W Pythonie dostępne są różne <strong>typy danych</strong>, takie jak liczby całkowite, zmiennoprzecinkowe, łańcuchy tekstowe i wartości logiczne.<br>- <strong>Operatory</strong> pozwalają na manipulowanie tymi danymi i tworzenie prostych obliczeń oraz warunków.</p><br><h3>"
          },

          {
            "id": 2,
            "title": "Operatory arytmetyczne i logiczne",
            "content": "</strong><br>W tej lekcji poznasz operatory arytmetyczne i logiczne, które pozwolą Ci na manipulację danymi w Pythonie. Dzięki nim będziesz mógł wykonywać obliczenia, porównania, a także operacje logiczne na danych. Operatorzy są niezbędni do tworzenia bardziej zaawansowanych programów.<br><br><h3>1. Operatory Arytmetyczne</h3><p>Operatory arytmetyczne umożliwiają wykonywanie podstawowych operacji matematycznych. Oto lista dostępnych operatorów:</p><ul><li><strong>+</strong> – dodawanie</li><li><strong>-</strong> – odejmowanie</li><li><strong>*</strong> – mnożenie</li><li><strong>/</strong> – dzielenie (wynik zawsze typu float)</li><li><strong>//</strong> – dzielenie całkowite (wynik to liczba całkowita)</li><li><strong>%</strong> – reszta z dzielenia (modulo)</li><li><strong>**</strong> – potęgowanie</li></ul><p><strong>Przykład użycia operatorów arytmetycznych:</strong></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>a = 10<br>b = 3<br>sum = a + b         # Dodawanie<br>difference = a - b  # Odejmowanie<br>product = a * b     # Mnożenie<br>quotient = a / b    # Dzielenie (float)<br>floor_division = a // b # Dzielenie całkowite<br>remainder = a % b    # Reszta z dzielenia<br>power = a ** b       # Potęgowanie</pre><p>W wyniku tych operacji zmienne będą przechowywać odpowiednie wartości, na przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>sum = 13       # Wynik 10 + 3<br>floor_division = 3 # Wynik 10 // 3</pre><br><h3>2. Operatory Logiczne</h3><p>Operatory logiczne pozwalają na wykonywanie operacji na wartościach logicznych (<code>True</code>, <code>False</code>). Są używane w warunkach oraz w porównaniach. W Pythonie dostępne są następujące operatory logiczne:</p><ul><li><strong>and</strong> – sprawdza, czy oba warunki są prawdziwe (zwraza <code>True</code> tylko wtedy, gdy oba warunki są <code>True</code>)</li><li><strong>or</strong> – sprawdza, czy przynajmniej jeden z warunków jest prawdziwy (zwraza <code>True</code> wtedy, gdy przynajmniej jeden warunek jest <code>True</code>)</li><li><strong>not</strong> – zmienia wartość logiczną (odwraca <code>True</code> na <code>False</code> i vice versa)</li></ul><p><strong>Przykład użycia operatorów logicznych:</strong></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>x = True<br>y = False<br>and_result = x and y    # False, ponieważ jeden warunek jest fałszywy<br>or_result = x or y      # True, ponieważ jeden warunek jest prawdziwy<br>not_result = not x      # False, odwracamy True na False</pre><p>Operator <code>and</code> zwraca <code>True</code> tylko wtedy, gdy oba warunki są prawdziwe, natomiast <code>or</code> zwraca <code>True</code>, jeśli przynajmniej jeden warunek jest prawdziwy. Operator <code>not</code> działa jak zaprzeczenie – zmienia wartość logiczną.</p><br><h3>3. Przykłady Zastosowania Operatorów w Warunkach</h3><p>Operatory arytmetyczne i logiczne są często wykorzystywane w instrukcjach warunkowych, takich jak <code>if</code>, aby sprawdzić, czy określony warunek jest spełniony.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>a = 10<br>b = 5<br>if a > b and a < 15:<br>    print(\"a jest większe od b i mniejsze niż 15\")</pre><p>W powyższym przykładzie, operator <code>and</code> sprawdza dwa warunki: <code>a > b</code> oraz <code>a < 15</code>. Jeśli oba warunki są prawdziwe, zostanie wypisany komunikat.</p><br><h3>4. Podsumowanie</h3><p>- <strong>Operatory arytmetyczne</strong> pozwalają na wykonywanie podstawowych obliczeń matematycznych, takich jak dodawanie, odejmowanie, mnożenie i dzielenie.<br>- <strong>Operatory logiczne</strong> pozwalają na sprawdzanie warunków i manipulację wartościami logicznymi (<code>True</code>, <code>False</code>).</p><br><h3>"
          }

          
        ]
      },
      {
        "id": 3,
        "title": "Kontrola przepływu programu",
        "description": "Zrozumiesz, jak zarządzać przepływem programu, używając pętli i instrukcji warunkowych.",
        "lessons": [
          {
            "id": 1,
            "title": "Instrukcja warunkowa if-else",
            "content": "W tej lekcji nauczysz się, jak używać instrukcji warunkowych, takich jak <code>if</code> i <code>if-else</code>, aby podejmować decyzje w programie. Dzięki tym instrukcjom będziesz mógł sprawdzać warunki i wykonywać różne operacje w zależności od tego, czy warunek jest prawdziwy, czy fałszywy. Instrukcja warunkowa jest jednym z najważniejszych narzędzi w programowaniu, które pozwala na kontrolowanie przepływu programu.<br><br><h3>1. Instrukcja if</h3><p>Instrukcja <code>if</code> pozwala na sprawdzenie, czy dany warunek jest prawdziwy. Jeśli tak, to wykonuje blok kodu, który znajduje się wewnątrz instrukcji. Jeśli warunek jest fałszywy, kod wewnątrz <code>if</code> jest pomijany.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>a = 10<br>if a > 5:<br>    print(\"a jest większe niż 5\")</pre><p>W tym przykładzie, ponieważ <code>a</code> jest większe niż 5, zostanie wypisany komunikat „<code>a jest większe niż 5</code>”.</p><br><h3>2. Instrukcja if-else</h3><p>Instrukcja <code>if-else</code> pozwala na wykonanie jednego bloku kodu, jeśli warunek jest prawdziwy, a innego, jeśli warunek jest fałszywy. Jest to rozszerzenie instrukcji <code>if</code>, które pozwala na alternatywne wykonanie kodu w zależności od wyniku warunku.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>a = 3<br>if a > 5:<br>    print(\"a jest większe niż 5\")<br>else:<br>    print(\"a nie jest większe niż 5\")</pre><p>W tym przypadku, ponieważ <code>a</code> jest mniejsze niż 5, zostanie wypisany komunikat „<code>a nie jest większe niż 5</code>”.</p><br><h3>3. Zagnieżdżone instrukcje if</h3><p>W Pythonie możesz zagnieżdżać instrukcje <code>if</code> w innych instrukcjach <code>if</code> lub <code>else</code>. Takie zagnieżdżenia pozwalają na sprawdzanie wielu warunków.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>a = 10<br>b = 5<br>if a > 5:<br>    if b > 3:<br>        print(\"a jest większe niż 5, a b jest większe niż 3\")</pre><p>W tym przykładzie, oba warunki są spełnione, więc na ekranie pojawi się komunikat „<code>a jest większe niż 5, a b jest większe niż 3</code>”.</p><br><h3>4. Instrukcja elif</h3><p>Jeśli masz więcej niż jeden warunek, możesz użyć instrukcji <code>elif</code>, co pozwoli na dodanie kolejnych alternatyw do instrukcji <code>if-else</code>. Instrukcja <code>elif</code> jest sprawdzana, jeśli wcześniejszy warunek był fałszywy, ale przed wykonaniem kodu <code>else</code>.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>a = 7<br>if a > 10:<br>    print(\"a jest większe niż 10\")<br>elif a == 7:<br>    print(\"a jest równe 7\")<br>else:<br>    print(\"a jest mniejsze niż 7\")</pre><p>W tym przypadku, ponieważ <code>a</code> wynosi 7, zostanie wypisany komunikat „<code>a jest równe 7</code>”.</p><br><h3>5. Przykład z użyciem instrukcji if-else</h3><p>Załóżmy, że chcesz napisać program, który sprawdzi, czy liczba jest liczbą parzystą czy nieparzystą. Możesz użyć instrukcji <code>if-else</code>, aby to zrobić:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>liczba = 6<br>if liczba % 2 == 0:<br>    print(\"Liczba jest parzysta\")<br>else:<br>    print(\"Liczba jest nieparzysta\")</pre><p>W wyniku tego programu, ponieważ <code>liczba</code> wynosi 6, zostanie wypisany komunikat „<code>Liczba jest parzysta</code>”.</p><br><h3>6. Podsumowanie</h3><p>- <strong>Instrukcja if</strong> pozwala na wykonanie kodu tylko wtedy, gdy warunek jest prawdziwy.<br>- <strong>Instrukcja if-else</strong> pozwala na alternatywne wykonanie dwóch bloków kodu w zależności od tego, czy warunek jest prawdziwy, czy fałszywy.<br>- <strong>Instrukcja elif</strong> pozwala na dodanie dodatkowych warunków.<br>- Możesz także <strong>zagnieżdżać instrukcje if</strong>, aby sprawdzać więcej warunków w jednym bloku kodu.</p><br><h3>"
          }

          ,
          {
            "id": 2,
            "title": "Pętle for i while",
            "content": "W tej lekcji nauczysz się, jak używać pętli w Pythonie, aby powtarzać blok kodu wielokrotnie. Pętle są niezwykle przydatne w programowaniu, ponieważ pozwalają na automatyczne wykonanie powtarzających się zadań. Pokażemy Ci, jak działają pętle <code>for</code> oraz <code>while</code> i jak je kontrolować.<br><br><h3>1. Pętla for</h3><p>Pętla <code>for</code> pozwala na iterowanie przez elementy w sekwencjach, takich jak listy, napisy, czy zakresy liczbowe. W każdej iteracji wykonywany jest blok kodu przypisany do tej pętli.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for i in range(5):<br>    print(i)</pre><p>W tym przykładzie <code>range(5)</code> generuje liczby od 0 do 4, a każda z nich jest wypisywana na ekranie.</p><p>Można również używać pętli <code>for</code> do iterowania po elementach listy:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>fruits = ['jabłko', 'banan', 'czereśnia']<br>for fruit in fruits:<br>    print(fruit)</pre><p>W tym przykładzie każdy owoc z listy <code>fruits</code> jest wypisywany osobno.</p><br><h3>2. Pętla while</h3><p>Pętla <code>while</code> wykonuje blok kodu tak długo, jak warunek jest spełniony. To oznacza, że musisz zadbać, aby warunek w końcu przestał być prawdziwy – inaczej pętla będzie działać w nieskończoność.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>count = 0<br>while count < 5:<br>    print(count)<br>    count += 1</pre><p>W tym przykładzie pętla działa pięć razy, ponieważ <code>count</code> rośnie o 1 w każdej iteracji, aż osiągnie wartość 5.</p><br><h3>3. Instrukcje break, continue, else</h3><p>W pętlach możesz używać instrukcji <code>break</code>, <code>continue</code> i <code>else</code>, aby lepiej kontrolować ich działanie.</p><p><strong>Instrukcja break:</strong> przerywa działanie pętli natychmiast.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for i in range(10):<br>    if i == 5:<br>        break<br>    print(i)</pre><p>Tutaj pętla kończy się, gdy <code>i</code> osiąga wartość 5.</p><p><strong>Instrukcja continue:</strong> pomija bieżącą iterację i przechodzi do następnej.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for i in range(5):<br>    if i == 3:<br>        continue<br>    print(i)</pre><p>Wynikiem działania tej pętli będą liczby 0, 1, 2, 4 – liczba 3 została pominięta.</p><p><strong>Instrukcja else:</strong> po pętli <code>for</code> lub <code>while</code> można dodać blok <code>else</code>, który zostanie wykonany tylko jeśli pętla zakończyła się naturalnie (nie przez <code>break</code>).</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for i in range(5):<br>    print(i)<br>else:<br>    print(\"Pętla zakończona\")</pre><p>W tym przypadku, po zakończeniu iteracji zostanie wypisany komunikat „<code>Pętla zakończona</code>”.</p><br><h3>4. Zagnieżdżone pętle</h3><p>Można zagnieżdżać jedną pętlę w drugiej, co pozwala na tworzenie bardziej złożonych struktur.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for i in range(3):<br>    for j in range(2):<br>        print(f\"i = {i}, j = {j}\")</pre><p>Ta pętla wypisze wszystkie kombinacje wartości <code>i</code> i <code>j</code>.</p><br><h3>5. Podsumowanie</h3><p>- <strong>Pętla for</strong> służy do iteracji po sekwencjach, takich jak listy czy zakresy liczb.<br>- <strong>Pętla while</strong> działa dopóki warunek jest prawdziwy.<br>- Instrukcje <strong>break</strong> i <strong>continue</strong> pozwalają na kontrolowanie przepływu pętli.<br>- Pętla może mieć blok <strong>else</strong>, wykonywany po jej naturalnym zakończeniu.<br>- Można używać <strong>zagnieżdżonych pętli</strong> dla bardziej zaawansowanych operacji.</p><br><h3>"
          }


          
        ]
      },
      {
        "id": 4,
        "title": "Funkcje",
        "description": "Nauczysz się definiować funkcje, które umożliwiają organizowanie kodu w bardziej modularny sposób.",
        "lessons": [
          {
            "id": 1,
            "title": "Tworzenie funkcji",
            "content": "Funkcje w Pythonie to blok kodu, który wykonuje określoną czynność. Dzięki funkcjom możemy ponownie wykorzystywać ten sam kod bez potrzeby jego powielania w różnych miejscach programu. Tworzenie funkcji pomaga w organizowaniu kodu, co czyni go bardziej czytelnym i łatwiejszym do zarządzania.<br><br><h3>1. Definiowanie funkcji</h3><p>Aby stworzyć funkcję w Pythonie, używamy słowa kluczowego <code>def</code>, a następnie podajemy nazwę funkcji oraz nawiasy, w których umieszczamy ewentualne argumenty. Na końcu deklaracji funkcji stawiamy dwukropek, a ciało funkcji musi być wcięte o cztery spacje. Funkcje muszą być wywoływane, aby zostały wykonane.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def przywitaj_sie():<br>    print(\"Witaj w Pythonie!\")</pre><p>W powyższym przykładzie funkcja <code>przywitaj_sie</code> po wywołaniu wypisuje na ekranie komunikat „Witaj w Pythonie!”.</p><br><h3>2. Jak wywołać funkcję?</h3><p>Po zdefiniowaniu funkcji możemy ją wywołać po prostu pisząc jej nazwę i dodając nawiasy. Nawiasy są obowiązkowe, nawet jeśli funkcja nie przyjmuje żadnych argumentów.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>przywitaj_sie()</pre><p>Po wywołaniu funkcji na ekranie pojawi się komunikat: <code>Witaj w Pythonie!</code></p><br><h3>3. Argumenty funkcji</h3><p>Funkcje mogą przyjmować argumenty, czyli wartości, które przekazujemy do funkcji podczas jej wywołania. Argumenty pozwalają na elastyczne działanie funkcji w zależności od wartości, które im przekażemy.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def przywitaj_imie(imie):<br>    print(f\"Cześć {imie}!\")</pre><p>W tym przypadku funkcja <code>przywitaj_imie</code> przyjmuje jeden argument – <code>imie</code>. Funkcja ta wypisuje powitanie, używając wartości przekazanej w argumencie.</p><p>Wywołanie funkcji z argumentem:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>przywitaj_imie(\"Anna\")</pre><p>Wynik: <code>Cześć Anna!</code></p><br><h3>4. Zwracanie wartości z funkcji</h3><p>Funkcje mogą również zwracać wartości, które mogą być używane w innych częściach programu. Zwracanie wartości odbywa się za pomocą słowa kluczowego <code>return</code>.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def dodaj(a, b):<br>    return a + b</pre><p>W tym przypadku funkcja <code>dodaj</code> przyjmuje dwa argumenty i zwraca ich sumę. Aby skorzystać z tej wartości, musimy przechować ją w zmiennej.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>wynik = dodaj(3, 5)<br>print(wynik)</pre><p>Wynik: <code>8</code></p><br><h3>5. Argumenty domyślne</h3><p>Argumenty funkcji mogą mieć przypisane wartości domyślne. Oznacza to, że jeśli nie przekażemy wartości dla danego argumentu podczas wywołania funkcji, zostanie użyta wartość domyślna. Wartości domyślne są przydatne, gdy chcemy, aby funkcja mogła działać w różnych przypadkach, nie wymuszając przekazywania wszystkich argumentów.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def przywitaj(imie = \"Gość\"):<br>    print(f\"Cześć {imie}!\")</pre><p>W tej funkcji, jeśli nie przekażemy żadnego argumentu, wartość <code>\"Gość\"</code> zostanie użyta jako domyślna. Przykłady wywołania:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>przywitaj()</pre><p>Wynik: <code>Cześć Gość!</code></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>przywitaj(\"Anna\")</pre><p>Wynik: <code>Cześć Anna!</code></p><br><h3>6. Funkcje z wieloma argumentami</h3><p>Funkcje mogą przyjmować wiele argumentów. Możemy również użyć operatora <code>*</code> do przekazywania zmiennej liczby argumentów. Operator <code>*</code> umożliwia przekazanie dowolnej liczby wartości do funkcji, które zostaną zebrane w krotkę (ang. tuple).</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def suma(*liczby):<br>    return sum(liczby)</pre><p>Funkcja <code>suma</code> zbiera wszystkie przekazane wartości i zwraca ich sumę. Możemy wywołać ją z dowolną liczbą argumentów:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>wynik = suma(1, 2, 3, 4, 5)<br>print(wynik)</pre><p>Wynik: <code>15</code></p><br><h3>7. Funkcje anonimowe (lambda)</h3><p>W Pythonie możemy również tworzyć funkcje anonimowe, tzw. funkcje lambda. Są one przydatne, gdy potrzebujemy prostych funkcji na jednorazowe użycie, np. jako argumenty dla innych funkcji.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>dodaj = lambda x, y: x + y<br>print(dodaj(3, 5))</pre><p>Wynik: <code>8</code></p><br><h3>8. Funkcje rekurencyjne</h3><p>Funkcje rekurencyjne to funkcje, które wywołują same siebie. Są one użyteczne, gdy problem można rozwiązać poprzez rozbicie go na mniejsze podproblemy. Przykład funkcji rekurencyjnej to obliczanie silni (n!).</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def silnia(n):<br>    if n == 1:<br>        return 1<br>    else:<br>        return n * silnia(n - 1)</pre><p>Funkcja <code>silnia</code> oblicza silnię liczby <code>n</code>. Wywołanie jej z argumentem <code>5</code> zwróci <code>120</code>.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(silnia(5))</pre><br><h3>9. Podsumowanie</h3><p>- Funkcje w Pythonie to sposób na organizowanie kodu i wielokrotne jego użycie.<br>- Funkcje mogą przyjmować argumenty i zwracać wartości.<br>- Możemy ustawiać wartości domyślne dla argumentów.<br>- Funkcje mogą przyjmować zmienną liczbę argumentów, a także tworzyć funkcje anonimowe i rekurencyjne.<br>- Funkcje pozwalają na bardziej elastyczne i zorganizowane tworzenie programów.</p><br><h3>"
          }


          
          ,
        {
          "id": 2,
          "title": "Parametry domyślne i argumenty",
          "content": "W tej lekcji dowiesz się, jak używać parametrów domyślnych w funkcjach oraz jak efektywnie zarządzać argumentami. Parametry domyślne umożliwiają funkcjom elastyczność, ponieważ pozwalają na przekazanie wartości tylko wtedy, gdy jest to konieczne. Dzięki temu można tworzyć funkcje, które będą działały w różnych sytuacjach, zależnie od liczby przekazanych argumentów.<br><br><h3>1. Co to są parametry domyślne?</h3><p>Parametry domyślne to takie, które mają przypisaną wartość w przypadku, gdy nie zostaną przekazane podczas wywołania funkcji. Parametry domyślne pozwalają na używanie funkcji w sposób bardziej elastyczny, bez konieczności przekazywania wszystkich wartości za każdym razem.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def powitanie(imie = \"Gość\"):\n    print(f\"Cześć {imie}!\")</pre><p>W powyższym przykładzie, funkcja <code>powitanie</code> ma parametr <code>imie</code> z wartością domyślną „Gość”. Jeśli nie przekażemy żadnej wartości dla tego parametru, funkcja użyje domyślnej wartości.</p><br><h3>2. Wywoływanie funkcji z parametrami domyślnymi</h3><p>Jeśli funkcja ma parametr domyślny, możemy wywołać ją na dwa sposoby:</p><ul><li>Przekazując wartość dla parametru, nadpisując domyślną wartość,</li><li>Nie przekazując wartości, dzięki czemu zostanie użyta wartość domyślna.</li></ul><p>Przykłady wywołania funkcji:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>powitanie(\"Anna\")</pre><p>Wynik: <code>Cześć Anna!</code></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>powitanie()</pre><p>Wynik: <code>Cześć Gość!</code></p><br><h3>3. Kiedy warto używać parametrów domyślnych?</h3><p>Parametry domyślne są szczególnie przydatne, gdy:</p><ul><li>Chcesz, aby funkcja działała z różną liczbą argumentów,</li><li>Masz standardową wartość, którą chcesz wykorzystać, jeśli użytkownik nie poda innej wartości,</li><li>Chcesz zachować kod funkcji prostym i elastycznym.</li></ul><br><h3>4. Wartości domyślne a zmienne</h3><p>Jeśli przypisujemy wartości domyślne do argumentów funkcji, pamiętajmy, że wartości te są przypisane do zmiennych tylko na początku wywołania funkcji. Możemy więc przekazać różne wartości w zależności od potrzeby, bez modyfikowania samej funkcji. Oto przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def mnoz(a, b = 2):\n    return a * b</pre><p>Funkcja <code>mnoz</code> ma drugi argument z wartością domyślną 2. Jeśli wywołamy ją bez drugiego argumentu, wynik będzie podwojeniem pierwszej liczby. Jeśli jednak przekażemy drugi argument, zostanie on użyty zamiast wartości domyślnej.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(mnoz(4))\nprint(mnoz(4, 3))</pre><p>Wyniki: <br><code>8</code><br><code>12</code></p><br><h3>5. Parametry domyślne a inne argumenty</h3><p>Jeśli w funkcji występują zarówno argumenty z wartościami domyślnymi, jak i bez, zawsze musimy najpierw podać argumenty obowiązkowe, a potem te, które mają wartości domyślne. Nie możemy przekazać argumentów domyślnych przed obowiązkowymi, bo spowodowałoby to błąd.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def przywitaj(imie, miasto = \"Nieznane\"):\n    print(f\"Cześć {imie}, z {miasto}!\")</pre><p>W tym przykładzie <code>imie</code> jest argumentem obowiązkowym, a <code>miasto</code> ma wartość domyślną. Możemy wywołać funkcję na dwa sposoby:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>przywitaj(\"Anna\")</pre><p>Wynik: <code>Cześć Anna, z Nieznane!</code></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>przywitaj(\"Anna\", \"Warszawa\")</pre><p>Wynik: <code>Cześć Anna, z Warszawa!</code></p><br><h3>6. Funkcje z zmienną liczbą argumentów ( *args )</h3><p>Czasami chcemy, aby funkcja przyjmowała zmienną liczbę argumentów. Możemy to osiągnąć, używając operatora <code>*</code>. Funkcja przyjmująca <code>*args</code> będzie zbierała wszystkie przekazane argumenty w krotkę.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def suma(*args):\n    return sum(args)</pre><p>Funkcja <code>suma</code> przyjmuje dowolną liczbę argumentów i zwraca ich sumę. Możemy ją wywołać w następujący sposób:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(suma(1, 2, 3))</pre><p>Wynik: <code>6</code></p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(suma(10, 20, 30, 40))</pre><p>Wynik: <code>100</code></p><br><h3>7. Parametry domyślne a funkcje z *args</h3><p>Jeśli używamy zarówno parametrów domyślnych, jak i <code>*args</code>, musimy pamiętać, aby parametry domyślne były zawsze wymienione przed <code>*args</code>, ponieważ <code>*args</code> zbiera wszystkie pozostałe argumenty. Dodatkowo, <code>*args</code> muszą występować na końcu listy argumentów.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def przywitaj(imie, *args):\n    print(f\"Cześć {imie}, masz {len(args)} dodatkowe argumenty.\")</pre><p>Możemy wywołać funkcję <code>przywitaj</code> w następujący sposób:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>przywitaj(\"Anna\", 5, 6, 7)</pre><p>Wynik: <code>Cześć Anna, masz 3 dodatkowe argumenty.</code></p><br><h3>8. Podsumowanie</h3><p>W tej lekcji nauczyliśmy się, jak używać parametrów domyślnych, aby uczynić funkcje bardziej elastycznymi, oraz jak zarządzać argumentami w funkcjach. Pamiętaj:</p><ul><li>Parametry domyślne umożliwiają przekazanie wartości tylko wtedy, gdy jest to konieczne.</li><li>Argumenty domyślne muszą występować po argumentach obowiązkowych.</li><li><code>*args</code> umożliwiają funkcji przyjmowanie zmiennej liczby argumentów.</li><li>Można łączyć parametry domyślne z <code>*args</code>, ale <code>*args</code> muszą występować na końcu listy argumentów.</li></ul><br><h3>"
        }


          
        ]
      },
      {
        "id": 5,
        "title": "Zbiory danych: listy, krotki, słowniki",
        "description": "Poznasz podstawowe struktury danych w Pythonie: listy, krotki oraz słowniki.",
        "lessons": [
          {
            "id": 1,
            "title": "Listy",
            "content": "W tej lekcji dowiesz się, jak przechowywać i manipulować danymi w listach. Listy są jednym z najważniejszych typów danych w Pythonie, które pozwalają na przechowywanie wielu elementów w jednym obiekcie. Listy są zmienne, co oznacza, że możemy je modyfikować po ich stworzeniu.<br><br><h3>1. Tworzenie listy</h3><p>Listy w Pythonie tworzymy za pomocą nawiasów kwadratowych <code>[]</code>, a poszczególne elementy oddzielamy przecinkami. Oto przykłady:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_lista = [1, 2, 3, 4, 5]</pre><p>W powyższym przykładzie lista <code>moja_lista</code> zawiera pięć liczb całkowitych. Listy mogą zawierać elementy różnych typów danych, na przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>mieszana_lista = [1, \"tekst\", 3.14, True]</pre><p>W tej liście znajduje się liczba całkowita, napis, liczba zmiennoprzecinkowa i wartość logiczna.</p><br><h3>2. Indeksowanie listy</h3><p>Elementy listy są numerowane od 0. Możemy uzyskać dostęp do elementu listy, używając indeksu. Przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_lista = [10, 20, 30, 40, 50]\nprint(moja_lista[0])  # Wynik: 10</pre><p>Wartość <code>10</code> jest pierwszym elementem listy, ponieważ indeks zaczyna się od 0. Jeśli chcemy uzyskać ostatni element listy, możemy użyć indeksu ujemnego:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(moja_lista[-1])  # Wynik: 50</pre><br><h3>3. Modyfikowanie listy</h3><p>Listy w Pythonie są zmienne, co oznacza, że możemy zmieniać ich zawartość po utworzeniu. Możemy modyfikować pojedyncze elementy listy, na przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_lista[0] = 100\nprint(moja_lista)  # Wynik: [100, 20, 30, 40, 50]</pre><p>W powyższym przykładzie zmieniliśmy pierwszy element listy na wartość <code>100</code>.</p><br><h3>4. Dodawanie i usuwanie elementów</h3><p>Python oferuje kilka metod do dodawania i usuwania elementów z listy:</p><ul><li><strong>append()</strong> - dodaje element na końcu listy:</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_lista.append(60)\nprint(moja_lista)  # Wynik: [10, 20, 30, 40, 50, 60]</pre><ul><li><strong>insert()</strong> - dodaje element w wybranym miejscu w liście (przed wskazanym indeksem):</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_lista.insert(2, 25)\nprint(moja_lista)  # Wynik: [10, 20, 25, 30, 40, 50, 60]</pre><ul><li><strong>remove()</strong> - usuwa pierwszy element o podanej wartości:</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_lista.remove(30)\nprint(moja_lista)  # Wynik: [10, 20, 25, 40, 50, 60]</pre><ul><li><strong>pop()</strong> - usuwa element o podanym indeksie (domyślnie ostatni element):</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_lista.pop()\nprint(moja_lista)  # Wynik: [10, 20, 25, 40, 50]</pre><br><h3>5. Łączenie list</h3><p>Listy można łączyć ze sobą za pomocą operatora <code>+</code>. Oto przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>lista1 = [1, 2, 3]\nlista2 = [4, 5, 6]\npołączona_lista = lista1 + lista2\nprint(połączona_lista)  # Wynik: [1, 2, 3, 4, 5, 6]</pre><br><h3>6. Powielanie list</h3><p>Możemy również powielać listy, używając operatora <code>*</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>lista = [1, 2, 3]\npowielona_lista = lista * 2\nprint(powielona_lista)  # Wynik: [1, 2, 3, 1, 2, 3]</pre><br><h3>7. Przechodzenie po liście</h3><p>Możemy przechodzić po elementach listy za pomocą pętli <code>for</code>. Oto przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for element in moja_lista:\n    print(element)</pre><p>Wynik:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>10\n20\n30\n40\n50</pre><br><h3>8. Listy zagnieżdżone</h3><p>Listy mogą zawierać inne listy. Takie listy nazywamy listami zagnieżdżonymi. Przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>lista_zagniezdzona = [[1, 2], [3, 4], [5, 6]]\nprint(lista_zagniezdzona[0])  # Wynik: [1, 2]</pre><p>Możemy także przechodzić po zagnieżdżonych listach, używając pętli:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for podlista in lista_zagniezdzona:\n    for element in podlista:\n        print(element)</pre><p>Wynik:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>1\n2\n3\n4\n5\n6</pre><br><h3>9. Funkcje i metody dla list</h3><p>Python oferuje szereg wbudowanych funkcji i metod do pracy z listami:</p><ul><li><strong>len()</strong> - zwraca długość listy:</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(len(moja_lista))  # Wynik: 5</pre><ul><li><strong>min()</strong> - zwraca najmniejszy element listy:</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(min(moja_lista))  # Wynik: 10</pre><ul><li><strong>max()</strong> - zwraca największy element listy:</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(max(moja_lista))  # Wynik: 50</pre><ul><li><strong>sum()</strong> - zwraca sumę elementów listy (dla liczb):</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(sum(moja_lista))  # Wynik: 150</pre><br><h3>10. Podsumowanie</h3><p>Listy to jeden z najczęściej używanych typów danych w Pythonie. Pozwalają one na przechowywanie wielu elementów, a dzięki swojej elastyczności możemy manipulować ich zawartością na wiele sposobów. Pamiętaj, że listy w Pythonie są zmienne, co pozwala na ich modyfikację w trakcie działania programu.</p><br><h3>"
          }

          ,
          {
            "id": 2,
            "title": "Krotki",
            "content": "W tej lekcji dowiesz się, czym różnią się krotki od list i kiedy warto ich używać. Krotki są bardzo podobne do list, ale mają jedną istotną różnicę: są niemutowalne, co oznacza, że po ich utworzeniu nie możemy zmieniać ich zawartości.<br><br><h3>1. Tworzenie krotek</h3><p>Krotki tworzymy za pomocą nawiasów okrągłych <code>()</code>, a elementy krotki oddzielamy przecinkami. Oto przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_krotka = (1, 2, 3, 4, 5)</pre><p>W powyższym przykładzie krotka <code>moja_krotka</code> zawiera pięć liczb całkowitych. Krotki, podobnie jak listy, mogą przechowywać elementy różnych typów danych:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>krotka_mieszana = (1, \"tekst\", 3.14, True)</pre><p>W tej krotce znajduje się liczba całkowita, napis, liczba zmiennoprzecinkowa i wartość logiczna.</p><br><h3>2. Różnice między krotkami a listami</h3><p>Główna różnica między krotkami a listami polega na tym, że krotki są <strong>niemutowalne</strong>, co oznacza, że nie można ich modyfikować po utworzeniu. Możesz tworzyć, przeglądać i używać krotek, ale nie możesz zmieniać ich zawartości. Listy natomiast są <strong>zmienne</strong>, co oznacza, że po ich utworzeniu możemy dodawać, usuwać i modyfikować elementy.</p><br><h3>3. Indeksowanie krotek</h3><p>Podobnie jak listy, krotki mają elementy, do których możemy uzyskać dostęp za pomocą indeksów, zaczynając od 0. Na przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>moja_krotka = (10, 20, 30, 40, 50)\nprint(moja_krotka[0])  # Wynik: 10</pre><p>Ostatni element krotki możemy uzyskać, używając indeksu ujemnego:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(moja_krotka[-1])  # Wynik: 50</pre><br><h3>4. Przechodzenie po krotkach</h3><p>Tak jak w przypadku list, możemy przechodzić po elementach krotki za pomocą pętli <code>for</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for element in moja_krotka:\n    print(element)</pre><p>Wynik:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>10\n20\n30\n40\n50</pre><br><h3>5. Łączenie krotek</h3><p>Krotki możemy łączyć ze sobą za pomocą operatora <code>+</code>, podobnie jak listy:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>krotka1 = (1, 2, 3)\nkrotka2 = (4, 5, 6)\npołączona_krotka = krotka1 + krotka2\nprint(połączona_krotka)  # Wynik: (1, 2, 3, 4, 5, 6)</pre><br><h3>6. Powielanie krotek</h3><p>Podobnie jak listy, krotki możemy powielać, używając operatora <code>*</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>krotka = (1, 2, 3)\npowielona_krotka = krotka * 2\nprint(powielona_krotka)  # Wynik: (1, 2, 3, 1, 2, 3)</pre><br><h3>7. Kiedy używać krotek?</h3><p>Krotki są doskonałym wyborem w sytuacjach, gdy chcesz przechowywać dane, które nie muszą być modyfikowane. Często są używane, gdy dane muszą być <strong>niezmienne</strong> (np. w przypadku współdzielenia danych między różnymi częściami programu), lub gdy elementy muszą być stosowane jako klucze w słownikach (ponieważ krotki są hashowalne, a listy nie). Krotki są również szybsze w działaniu niż listy, gdyż są mniej zasobożerne.</p><br><h3>8. Zagnieżdżone krotki</h3><p>Podobnie jak listy, krotki mogą zawierać inne krotki, tworząc krotki zagnieżdżone. Oto przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>krotka_zagniezdzona = ((1, 2), (3, 4), (5, 6))\nprint(krotka_zagniezdzona[0])  # Wynik: (1, 2)</pre><p>Możemy przechodzić po zagnieżdżonych krotkach, używając pętli:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for podkrotka in krotka_zagniezdzona:\n    for element in podkrotka:\n        print(element)</pre><p>Wynik:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>1\n2\n3\n4\n5\n6</pre><br><h3>9. Funkcje i metody dla krotek</h3><p>Choć krotki są niemutowalne, oferują kilka funkcji i metod, które mogą być użyteczne:</p><ul><li><strong>len()</strong> - zwraca długość krotki:</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(len(moja_krotka))  # Wynik: 5</pre><ul><li><strong>min()</strong> - zwraca najmniejszy element krotki:</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(min(moja_krotka))  # Wynik: 10</pre><ul><li><strong>max()</strong> - zwraca największy element krotki:</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(max(moja_krotka))  # Wynik: 50</pre><ul><li><strong>sum()</strong> - zwraca sumę elementów krotki (dla liczb):</li></ul><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(sum(moja_krotka))  # Wynik: 150</pre><br><h3>10. Podsumowanie</h3><p>Krotki są bardzo podobne do list, ale różnią się tym, że są niemutowalne, co sprawia, że są bezpieczniejsze i szybsze w użyciu, gdy nie chcemy, aby dane były zmieniane. Używaj krotek, gdy potrzebujesz przechować dane, które nie powinny być modyfikowane, lub gdy pracujesz z danymi, które będą używane jako klucze w słownikach.</p><br><h3>"
          }

          ,
          {
            "id": 3,
            "title": "Słowniki",
            "content": "W tej lekcji nauczysz się, jak używać słowników do przechowywania danych w formie par klucz-wartość. Słowniki są bardzo elastyczne i pozwalają na szybki dostęp do danych za pomocą kluczy.<br><br><h3>1. Tworzenie słowników</h3><p>Słowniki w Pythonie tworzymy za pomocą nawiasów klamrowych <code>{}</code>, a każda para klucz-wartość jest oddzielona dwukropkiem <code>:</code>. Pary klucz-wartość są rozdzielone przecinkami. Oto przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>slownik = {\"imie\": \"Anna\", \"wiek\": 25, \"miasto\": \"Warszawa\"}</pre><p>W tym przykładzie mamy słownik, który przechowuje informacje o imieniu, wieku i mieście. Klucze to <code>\"imie\"</code>, <code>\"wiek\"</code> i <code>\"miasto\"</code>, a odpowiadające im wartości to odpowiednio <code>\"Anna\"</code>, <code>25</code> i <code>\"Warszawa\"</code>.</p><br><h3>2. Dostęp do wartości w słowniku</h3><p>Do wartości w słowniku uzyskujemy dostęp, podając klucz w nawiasach kwadratowych. Przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>slownik = {\"imie\": \"Anna\", \"wiek\": 25, \"miasto\": \"Warszawa\"}<br>print(slownik[\"imie\"])  # Wynik: Anna</pre><p>Jeśli podamy klucz, który nie istnieje w słowniku, otrzymamy błąd <code>KeyError</code>. Aby uniknąć tego błędu, możemy użyć metody <code>get()</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(slownik.get(\"imie\"))  # Wynik: Anna</pre><p>Jeśli klucz nie istnieje, metoda <code>get()</code> zwróci <code>None</code> zamiast błędu:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(slownik.get(\"adres\"))  # Wynik: None</pre><br><h3>3. Dodawanie i modyfikowanie elementów w słowniku</h3><p>Aby dodać nową parę klucz-wartość lub zmienić wartość istniejącego klucza, wystarczy przypisać nową wartość do klucza:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>slownik[\"zawod\"] = \"Programista\"</pre><p>Wartość dla klucza <code>\"zawod\"</code> została dodana do słownika, a wartość dla tego klucza to teraz <code>\"Programista\"</code>.</p><br><h3>4. Usuwanie elementów ze słownika</h3><p>Aby usunąć parę klucz-wartość ze słownika, możemy użyć operatora <code>del</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>del slownik[\"wiek\"]</pre><p>Po tym poleceniu klucz <code>\"wiek\"</code> i jego wartość zostaną usunięte ze słownika.</p><p>Możemy także użyć metody <code>pop()</code>, która nie tylko usuwa element, ale również zwraca jego wartość:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>wiek = slownik.pop(\"wiek\")<br>print(wiek)  # Wynik: 25</pre><br><h3>5. Iterowanie po słowniku</h3><p>Podobnie jak w przypadku innych struktur danych, możemy przechodzić po słowniku za pomocą pętli <code>for</code>. Możemy iterować po kluczach, wartościach lub parach klucz-wartość:</p><br><h4>Iteracja po kluczach:</h4><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for klucz in slownik:<br>    print(klucz)</pre><p>Wynik:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>imie<br>wiek<br>miasto<br>zawod</pre><br><h4>Iteracja po wartościach:</h4><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for wartosc in slownik.values():<br>    print(wartosc)</pre><p>Wynik:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>Anna<br>25<br>Warszawa<br>Programista</pre><br><h4>Iteracja po parach klucz-wartość:</h4><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>for klucz, wartosc in slownik.items():<br>    print(f\"Klucz: {klucz}, Wartość: {wartosc}\")</pre><p>Wynik:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>Klucz: imie, Wartość: Anna<br>Klucz: wiek, Wartość: 25<br>Klucz: miasto, Wartość: Warszawa<br>Klucz: zawod, Wartość: Programista</pre><br><h3>6. Zagnieżdżanie słowników</h3><p>Słowniki mogą zawierać inne słowniki, tworząc słowniki zagnieżdżone. Oto przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>slownik_zagniezdzony = {\"osoba\": {\"imie\": \"Anna\", \"wiek\": 25}, \"miasto\": \"Warszawa\"}</pre><p>Aby uzyskać dostęp do elementu w zagnieżdżonym słowniku, musimy podać klucz do zagnieżdżonego słownika:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>print(slownik_zagniezdzony[\"osoba\"][\"imie\"])  # Wynik: Anna</pre><br><h3>7. Słowniki a porównanie</h3><p>Słowniki w Pythonie są porównywane na podstawie swoich par klucz-wartość. Oznacza to, że dwa słowniki są równe, jeśli mają te same klucze i odpowiadające im wartości:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>slownik1 = {\"imie\": \"Anna\", \"wiek\": 25}<br>slownik2 = {\"imie\": \"Anna\", \"wiek\": 25}<br>print(slownik1 == slownik2)  # Wynik: True</pre><br><h3>8. Podsumowanie</h3><p>Słowniki w Pythonie są niezwykle użytecznym narzędziem do przechowywania danych w postaci par klucz-wartość. Słowniki pozwalają na szybki dostęp do wartości za pomocą kluczy oraz umożliwiają łatwe dodawanie, modyfikowanie i usuwanie danych. Zagnieżdżone słowniki oraz iteracja po elementach to tylko niektóre z ich możliwości.</p><br><h3>"
          }

          
        ]
      },
      {
        "id": 6,
        "title": "Podstawy obsługi wyjątków",
        "description": "Dowiesz się, jak obsługiwać błędy i wyjątki w Pythonie, by twój kod był odporny na nieprzewidziane sytuacje.",
        "lessons": [
         {
          "id": 1,
          "title": "Bloki try-except",
          "content": "W tej lekcji dowiesz się, jak używać bloków <code>try-except</code> do obsługi wyjątków, czyli sytuacji, które mogą powodować błędy w programie. Bloki te pozwalają na przechwytywanie błędów i kontrolowanie przepływu programu, zamiast kończyć jego działanie w momencie wystąpienia błędu.<br><br><h3>1. Podstawowa struktura try-except</h3><p>Blok <code>try</code> zawiera kod, który może wygenerować wyjątek, a blok <code>except</code> zawiera kod, który ma być wykonany, gdy wyjątek zostanie przechwycony:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>try:<br>    # Kod, który może wygenerować wyjątek<br>    wynik = 10 / 0<br>except ZeroDivisionError:<br>    # Kod obsługujący wyjątek<br>    print(\"Nie można dzielić przez zero!\")</pre><p>W powyższym przykładzie próbujemy wykonać dzielenie przez zero, co spowoduje błąd <code>ZeroDivisionError</code>. Zamiast zakończyć program, wyjątek zostaje przechwycony, a użytkownik otrzymuje komunikat o błędzie.</p><br><h3>2. Obsługa różnych wyjątków</h3><p>Możemy przechwycić różne rodzaje wyjątków, stosując kilka bloków <code>except</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>try:<br>    # Kod, który może wygenerować wyjątek<br>    liczba = int(input(\"Podaj liczbę: \"))<br>    wynik = 10 / liczba<br>except ValueError:<br>    print(\"To nie jest poprawna liczba!\")<br>except ZeroDivisionError:<br>    print(\"Nie można dzielić przez zero!\")</pre><p>W tym przypadku, jeśli użytkownik poda wartość, która nie jest liczbą, zostanie przechwycony wyjątek <code>ValueError</code>, a jeśli poda zero, zostanie przechwycony wyjątek <code>ZeroDivisionError</code>.</p><br><h3>3. Blok else</h3><p>Możemy dodać blok <code>else</code>, który zostanie wykonany, jeśli nie wystąpi żaden wyjątek. Blok ten jest opcjonalny:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>try:<br>    wynik = 10 / 5<br>except ZeroDivisionError:<br>    print(\"Nie można dzielić przez zero!\")<br>else:<br>    print(\"Operacja zakończona pomyślnie!\")</pre><p>W tym przykładzie, ponieważ dzielenie przez 5 nie powoduje błędu, zostanie wykonany blok <code>else</code>, a na ekranie pojawi się komunikat o pomyślnym zakończeniu operacji.</p><br><h3>4. Blok finally</h3><p>Blok <code>finally</code> jest wykonywany zawsze, niezależnie od tego, czy wyjątek wystąpił, czy nie. Jest to dobre miejsce do umieszczenia kodu, który musi być wykonany niezależnie od sytuacji, np. do zamknięcia pliku:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>try:<br>    plik = open(\"plik.txt\", \"r\")<br>    # Praca z plikiem<br>except FileNotFoundError:<br>    print(\"Nie znaleziono pliku!\")<br>finally:<br>    plik.close()<br>    print(\"Plik został zamknięty.\")</pre><p>W tym przykładzie, niezależnie od tego, czy plik zostanie znaleziony, czy nie, zostanie on zamknięty w bloku <code>finally</code>.</p><br><h3>5. Przechwytywanie ogólnych wyjątków</h3><p>Jeśli chcemy przechwycić wszystkie możliwe wyjątki, możemy użyć ogólnego wyjątku <code>Exception</code>. Jednak należy to robić ostrożnie, ponieważ przechwytywanie wszystkich wyjątków może ukryć istotne błędy:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>try:<br>    wynik = 10 / 0<br>except Exception as e:<br>    print(f\"Wystąpił błąd: {e}\")</pre><p>W tym przypadku przechwytujemy wszelkie wyjątki i wypisujemy komunikat o błędzie.</p><br><h3>6. Zwracanie wyjątków</h3><p>W Pythonie możemy również sami rzucać wyjątki za pomocą słowa kluczowego <code>raise</code>. Rzucanie wyjątków może być przydatne, gdy chcemy wymusić określony warunek w programie:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def sprawdz_wiek(wiek):<br>    if wiek < 18:<br>        raise ValueError(\"Musisz mieć przynajmniej 18 lat!\")<br>    print(\"Dostęp do programu przyznany.\")</pre><p>W tym przykładzie, jeśli użytkownik poda wiek mniejszy niż 18, zostanie rzucony wyjątek <code>ValueError</code> z odpowiednim komunikatem.</p><br><h3>7. Podsumowanie</h3><p>Bloki <code>try-except</code> są kluczowe w zarządzaniu wyjątkami w Pythonie. Dzięki nim możemy przechwytywać błędy, kontrolować przepływ programu i reagować na nie w sposób, który nie kończy pracy całego programu. Dodatkowo, możemy używać bloków <code>else</code> i <code>finally</code>, aby jeszcze lepiej zarządzać przepływem kodu oraz jego obsługą. Pamiętaj, aby używać wyjątków odpowiedzialnie, aby nie ukrywać istotnych błędów w kodzie.</p><br><h3>"
        }

          ,
         {
          "id": 2,
          "title": "Podnoszenie wyjątków",
          "content": "W tej lekcji dowiesz się, jak samodzielnie podnosić wyjątki w Pythonie, aby lepiej kontrolować przepływ programu. Podnoszenie wyjątków pozwala na sygnalizowanie błędów w kodzie i przekazywanie ich dalej w programie w celu późniejszej obsługi.<br><br><h3>1. Podstawowe podnoszenie wyjątków</h3><p>Podnoszenie wyjątków w Pythonie odbywa się za pomocą słowa kluczowego <code>raise</code>. Możemy go użyć, aby ręcznie rzucić wyjątek, np. gdy napotkamy błąd w danej funkcji lub chcemy wymusić określony warunek:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def sprawdz_wiek(wiek):<br>    if wiek < 18:<br>        raise ValueError(\"Musisz mieć przynajmniej 18 lat!\")<br>    print(\"Dostęp do programu przyznany.\")</pre><p>W tym przykładzie, jeśli użytkownik poda wiek mniejszy niż 18, zostanie rzucony wyjątek <code>ValueError</code> z odpowiednim komunikatem.</p><br><h3>2. Podnoszenie wyjątków z własnymi komunikatami</h3><p>Podnosząc wyjątek, możemy również dodać do niego własny komunikat, który pomoże w diagnostyce błędu. Komunikat ten zostanie wyświetlony, gdy wyjątek zostanie przechwycony przez blok <code>except</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>def dzielenie(a, b):<br>    if b == 0:<br>        raise ZeroDivisionError(\"Nie można dzielić przez zero!\")<br>    return a / b</pre><p>W tym przypadku, jeśli użytkownik spróbuje podzielić przez zero, zostanie podniesiony wyjątek <code>ZeroDivisionError</code> z niestandardowym komunikatem.</p><br><h3>3. Podnoszenie istniejącego wyjątku</h3><p>Możemy także podnieść wyjątek, który został przechwycony w bloku <code>except</code>. Może to być przydatne, gdy chcemy przekazać wyjątek dalej w programie:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>try:<br>    wiek = int(input(\"Podaj swój wiek: \"))<br>except ValueError as e:<br>    print(f\"Wystąpił błąd: {e}\")<br>    raise  # Ponowne podniesienie tego samego wyjątku</pre><p>W tym przykładzie, jeśli użytkownik nie poda liczby, zostanie przechwycony wyjątek <code>ValueError</code>, a następnie ten sam wyjątek zostanie podniesiony ponownie przy użyciu słowa kluczowego <code>raise</code>.</p><br><h3>4. Podnoszenie własnych wyjątków</h3><p>W Pythonie możemy tworzyć własne klasy wyjątków, które pozwalają na bardziej zaawansowaną obsługę błędów w programie. Możemy stworzyć klasę wyjątku, dziedzicząc po klasie <code>Exception</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>class WiekZbytMalyError(Exception):<br>    def __init__(self, message):<br>        super().__init__(message)<br><br>def sprawdz_wiek(wiek):<br>    if wiek < 18:<br>        raise WiekZbytMalyError(\"Wiek musi wynosić co najmniej 18 lat.\")<br>    print(\"Dostęp do programu przyznany.\")</pre><p>W tym przykładzie stworzyliśmy klasę wyjątku <code>WiekZbytMalyError</code>, która jest używana do podnoszenia wyjątków w przypadku, gdy użytkownik nie spełnia wymaganego wieku.</p><br><h3>5. Podsumowanie</h3><p>Podnoszenie wyjątków w Pythonie jest potężnym narzędziem, które pozwala na lepszą kontrolę nad przepływem programu, zwłaszcza gdy napotykamy błędy lub nieoczekiwane sytuacje. Możemy podnosić wyjątki za pomocą słowa kluczowego <code>raise</code>, dodawać do nich własne komunikaty, a także tworzyć własne klasy wyjątków. Podnoszenie wyjątków może pomóc w wymuszaniu określonych warunków w programie oraz umożliwia skuteczną diagnostykę błędów.</p><br><h3>"
        }

          
        ]
      },
      {
        "id": 7,
        "title": "Praca z plikami",
        "description": "Nauczysz się, jak odczytywać i zapisywać dane do plików tekstowych.",
        "lessons": [
          {
            "id": 1,
            "title": "Otwieranie i odczyt plików",
            "content": "W tej lekcji dowiesz się, jak otworzyć plik w Pythonie w trybie do odczytu, jak odczytać jego zawartość oraz jak bezpiecznie pracować z plikami.<br><br><h3>1. Co to jest plik?</h3><p>Plik to zbiór danych, które są przechowywane na dysku. W Pythonie możemy otwierać pliki, aby odczytać lub zapisać dane. Każdy plik ma swój format, np. tekstowy (.txt), CSV (.csv), JSON (.json), itp. Zajmiemy się plikami tekstowymi, które są najczęściej wykorzystywane.</p><br><h3>2. Otwieranie pliku w trybie do odczytu</h3><p>Aby otworzyć plik w Pythonie, używamy funkcji <code>open()</code>. Funkcja ta przyjmuje dwa argumenty:</p><ul><li><code>nazwa_pliku</code> — nazwa pliku, który chcemy otworzyć (wraz z rozszerzeniem, np. 'dane.txt').</li><li><code>tryb</code> — określa, w jakim trybie chcemy otworzyć plik. Tryb <code>'r'</code> oznacza, że plik będzie otwarty do odczytu.</li></ul><p>Przykład:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>plik = open('przykladowy_plik.txt', 'r')</pre><p>Jeśli plik nie istnieje, Python zgłosi błąd <code>FileNotFoundError</code>.</p><br><h3>3. Odczyt zawartości pliku</h3><p>Po otwarciu pliku, możemy odczytać jego zawartość za pomocą różnych metod:</p><ul><li><code>read()</code> — odczytuje cały plik w postaci pojedynczego łańcucha tekstowego. Jeśli plik jest bardzo duży, może to zużyć dużo pamięci.</li><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>zawartosc = plik.read()</pre><li><code>readline()</code> — odczytuje jedną linię z pliku. Jest przydatne, gdy chcemy odczytać plik linia po linii, bez wczytywania całej zawartości na raz.</li><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>linia = plik.readline()</pre><li><code>readlines()</code> — odczytuje cały plik, ale zamiast zwracać go jako pojedynczy łańcuch tekstowy, zwraca go jako listę, gdzie każda linia jest osobnym elementem listy.</li><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>linie = plik.readlines()</pre></ul><br><h3>4. Zamykanie pliku</h3><p>Po zakończeniu pracy z plikiem, należy go zamknąć, aby zwolnić zasoby systemowe. Do tego służy metoda <code>close()</code>:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>plik.close()</pre><p>Jednak zamiast ręcznie zamykać plik, lepiej jest używać kontekstu menedżera, który automatycznie zajmuje się zamknięciem pliku po zakończeniu pracy z nim.</p><br><h3>5. Korzystanie z kontekstu menedżera (with)</h3><p>Aby upewnić się, że plik zostanie zamknięty po zakończeniu pracy, używamy kontekstu menedżera z instrukcją <code>with</code>. Dzięki temu plik jest zamykany automatycznie, nawet jeśli w trakcie pracy pojawi się wyjątek.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>with open('przykladowy_plik.txt', 'r') as plik:<br>    zawartosc = plik.read()</pre><p>Po zakończeniu bloku kodu plik jest automatycznie zamykany, bez potrzeby wywoływania <code>close()</code>.</p><br><h3>6. Odczyt pliku linia po linii</h3><p>Jeśli chcemy odczytać plik linia po linii, zamiast używać <code>read()</code>, możemy użyć pętli <code>for</code>. W ten sposób nie musimy odczytywać całego pliku do pamięci, co jest bardziej efektywne, zwłaszcza w przypadku dużych plików.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>with open('przykladowy_plik.txt', 'r') as plik:<br>    for linia in plik:<br>        print(linia.strip())</pre><p>Funkcja <code>strip()</code> służy do usuwania zbędnych białych znaków (np. znaków nowej linii) z końca każdej linii.</p><br><h3>7. Obsługa wyjątków przy otwieraniu pliku</h3><p>Podczas pracy z plikami mogą wystąpić różne błędy, np. plik może nie istnieć, lub nie mamy wystarczających uprawnień do jego odczytu. W takich przypadkach warto używać bloków <code>try-except</code>, które pozwolą na obsługę wyjątków w sposób bezpieczny.</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>try:<br>    with open('przykladowy_plik.txt', 'r') as plik:<br>        zawartosc = plik.read()<br>except FileNotFoundError:<br>    print('Plik nie został znaleziony!')</pre><p>W tym przykładzie, jeśli plik nie zostanie znaleziony, program wypisze komunikat błędu, zamiast zakończyć działanie z wyjątkiem.</p><br><h3>8. Przykład pełnej pracy z plikiem</h3><p>Poniżej znajduje się pełny przykład, który pokazuje, jak otworzyć plik, odczytać jego zawartość, obsłużyć wyjątki i zamknąć plik:</p><pre class='code-block' style='background:#e6f2ff;padding:1rem;border-radius:6px;margin:1rem 0;font-family:Courier New, monospace;font-size:1rem;border:1px solid #b3d1ff;overflow-x:auto;'>try:<br>    with open('przykladowy_plik.txt', 'r') as plik:<br>        zawartosc = plik.read()<br>        print('Zawartość pliku:\\n', zawartosc)<br>except FileNotFoundError:<br>    print('Plik nie został znaleziony!')</pre><p>W tym przypadku, jeśli plik istnieje, zostanie wypisana jego zawartość. Jeśli plik nie zostanie znaleziony, użytkownik zobaczy odpowiedni komunikat o błędzie.</p><br><h3>9. Co dalej?</h3><p>Po opanowaniu podstawowego odczytu plików, w kolejnych lekcjach zapoznamy się z zapisem danych do pliku oraz bardziej zaawansowanymi technikami pracy z plikami (np. odczyt plików CSV, JSON itp.).</p><br><h3>10. Podsumowanie</h3><p>W tej lekcji nauczyłeś się, jak otwierać pliki w Pythonie w trybie do odczytu, jak odczytywać ich zawartość (metody <code>read()</code>, <code>readline()</code>, <code>readlines()</code>), jak bezpiecznie zamknąć plik oraz jak obsługiwać wyjątki związane z plikami. Korzystanie z kontekstu menedżera zapewnia, że plik zostanie zamknięty automatycznie po zakończeniu pracy, co jest bardziej efektywne i bezpieczne.</p><br><h3>"
          },

          {
            "id": 2,
            "title": "Zapis do plików",
            "content": "W tej lekcji dowiesz się, jak zapisywać dane do pliku w Pythonie, w jakich trybach możesz otworzyć plik i jak bezpiecznie zamknąć plik po zakończeniu pracy.<br><br><h3>1. Co to jest zapis do pliku?</h3><p>Zapis do pliku pozwala na przechowywanie danych w plikach na dysku. Jest to przydatne, gdy chcemy zapisać wyniki obliczeń, dane wprowadzane przez użytkownika, czy inne informacje, które muszą być przechowywane poza programem. W Pythonie do zapisu danych w plikach używamy funkcji <code>open()</code> w odpowiednich trybach.</p><br><h3>2. Tryby otwierania plików</h3><p>Podobnie jak w przypadku odczytu plików, przy zapisie musimy określić tryb otwarcia pliku. Najczęściej używane tryby to:</p><ul><li><code>'w'</code> — tryb zapisu (write), który tworzy nowy plik, jeśli nie istnieje, lub nadpisuje istniejący plik.</li><li><code>'a'</code> — tryb dopisywania (append), który umożliwia dopisanie nowych danych do końca pliku (nie nadpisuje istniejących danych).</li><li><code>'x'</code> — tryb tworzenia (exclusive), który tworzy nowy plik, ale zgłasza błąd, jeśli plik już istnieje.</li></ul><br><h3>3. Zapis do pliku w trybie 'w'</h3><p>Tryb <code>'w'</code> nadpisuje plik, więc jeśli plik już istnieje, jego zawartość zostanie usunięta. Jeśli plik nie istnieje, zostanie stworzony nowy.</p><p>Przykład:</p><pre class='code-block' style='background:#e6f2ff; padding:1rem; border-radius:6px; margin:1rem 0; font-family: \"Courier New\", monospace; font-size:1rem; border:1px solid #b3d1ff; overflow-x:auto;'>with open('przykladowy_plik.txt', 'w') as plik:\n    plik.write('Hello, world!')</pre><p>W tym przykładzie otwieramy plik w trybie zapisu i zapisujemy do niego tekst \"Hello, world!\". Po zakończeniu pracy plik zostanie automatycznie zamknięty dzięki kontekstowi menedżera.</p><br><h3>4. Zapis do pliku w trybie 'a'</h3><p>Jeśli chcemy dopisać dane do istniejącego pliku, zamiast go nadpisywać, używamy trybu <code>'a'</code>. W tym trybie nowe dane zostaną dodane na końcu pliku.</p><pre class='code-block' style='background:#e6f2ff; padding:1rem; border-radius:6px; margin:1rem 0; font-family: \"Courier New\", monospace; font-size:1rem; border:1px solid #b3d1ff; overflow-x:auto;'>with open('przykladowy_plik.txt', 'a') as plik:\n    plik.write('Dopisana linia tekstu.\\n')</pre><p>W tym przypadku dane zostaną dodane na końcu pliku, a zawartość pliku nie zostanie nadpisana.</p><br><h3>5. Zapis wielu linii do pliku</h3><p>Jeśli chcemy zapisać wiele linii tekstu, możemy użyć metody <code>writelines()</code>. Ta metoda zapisuje listę, gdzie każdy element listy będzie zapisywany jako osobna linia w pliku.</p><pre class='code-block' style='background:#e6f2ff; padding:1rem; border-radius:6px; margin:1rem 0; font-family: \"Courier New\", monospace; font-size:1rem; border:1px solid #b3d1ff; overflow-x:auto;'>linie = ['Pierwsza linia.\\n', 'Druga linia.\\n', 'Trzecia linia.\\n']\nwith open('przykladowy_plik.txt', 'w') as plik:\n    plik.writelines(linie)</pre><p>W tym przykładzie lista <code>linie</code> zostanie zapisana do pliku, a każda linia zostanie zapisana w osobnym wierszu.</p><br><h3>6. Jak dbać o zamknięcie pliku?</h3><p>Po zapisaniu danych do pliku zawsze należy go zamknąć, aby upewnić się, że dane zostały zapisane i zasoby zostały zwolnione. Możemy to zrobić ręcznie, wywołując <code>close()</code>, ale lepiej używać kontekstu menedżera (instrukcja <code>with</code>), który automatycznie zamknie plik po zakończeniu pracy.</p><br><h3>7. Obsługa wyjątków przy zapisie pliku</h3><p>Podczas pracy z plikami mogą wystąpić błędy, takie jak brak uprawnień do zapisu, pełny dysk lub brak miejsca. Aby obsłużyć te błędy, możemy użyć bloków <code>try-except</code>, aby zapobiec awarii programu.</p><pre class='code-block' style='background:#e6f2ff; padding:1rem; border-radius:6px; margin:1rem 0; font-family: \"Courier New\", monospace; font-size:1rem; border:1px solid #b3d1ff; overflow-x:auto;'>try:\n    with open('przykladowy_plik.txt', 'w') as plik:\n        plik.write('Nowa zawartość pliku.')\nexcept IOError:\n    print('Wystąpił błąd podczas zapisu do pliku!')</pre><p>W tym przykładzie, jeśli wystąpi błąd podczas zapisu, np. brak uprawnień, program wyświetli komunikat o błędzie.</p><br><h3>8. Przykład pełnego zapisu do pliku</h3><p>Przykład pełnego kodu, który pokazuje zapis do pliku oraz obsługę błędów:</p><pre class='code-block' style='background:#e6f2ff; padding:1rem; border-radius:6px; margin:1rem 0; font-family: \"Courier New\", monospace; font-size:1rem; border:1px solid #b3d1ff; overflow-x:auto;'>try:\n    with open('przykladowy_plik.txt', 'w') as plik:\n        plik.write('Pierwsza linia.\\n')\n        plik.write('Druga linia.\\n')\n    print('Zapis do pliku zakończony sukcesem!')\nexcept IOError:\n    print('Wystąpił błąd podczas zapisu do pliku!')</pre><br><h3>9. Co dalej?</h3><p>Po opanowaniu zapisu do plików, możesz rozszerzyć swoje umiejętności o zapisywanie bardziej złożonych danych, np. zapis obiektów Python (JSON, CSV). W kolejnych lekcjach dowiesz się, jak pracować z bardziej zaawansowanymi formatami danych.</p><br><h3>10. Podsumowanie</h3><p>W tej lekcji nauczyłeś się, jak zapisywać dane do pliku w Pythonie, zarówno w trybie nadpisywania pliku ('w'), jak i dopisywania do niego ('a'). Dowiedziałeś się również, jak zapisywać wiele linii tekstu oraz jak obsługiwać wyjątki związane z zapisem danych do pliku. Używanie kontekstu menedżera (instrukcja <code>with</code>) zapewnia, że plik zostanie automatycznie zamknięty po zakończeniu pracy, co jest bezpieczne i efektywne.</p><br><h3>"
          }

        ]
      
      }
    ],
     "quiz": {
      "questions": [
        {
          "id": 1,
          "question": "Co należy zrobić, aby móc uruchamiać Pythona z poziomu terminala po instalacji?",
          "answers": [
            "Nic, Python działa od razu",
            "Dodać Python do zmiennej środowiskowej PATH podczas instalacji",
            "Uruchomić komputer ponownie",
            "Zainstalować dodatkowe oprogramowanie"
          ],
          "correct": [1],
          "points": 1
        },
        {
          "id": 2,
          "question": "Jaką funkcję w Pythonie używamy, aby pobrać dane wpisane przez użytkownika z klawiatury?",
          "answers": [
            "print()",
            "input()",
            "read()",
            "scan()"
          ],
          "correct": [1],
          "points": 1
        },
        {
          "id": 3,
          "question": "Który z poniższych typów danych w Pythonie służy do przechowywania wartości logicznych?",
          "answers": [
            "int",
            "str",
            "bool",
            "float"
          ],
          "correct": [2],
          "points": 1
        },
        {
          "id": 4,
          "question": "Który operator w Pythonie zwraca resztę z dzielenia dwóch liczb?",
          "answers": [
            "/",
            "//",
            "**",
            "%"
          ],
          "correct": [3],
          "points": 1
        },
       {
          "id": 5,
          "question": "Które z poniższych stwierdzeń dotyczących instrukcji warunkowych w Pythonie jest prawdziwe?",
          "answers": [
            "Instrukcja if zawsze wymaga użycia bloku else.",
            "Instrukcja elif pozwala na sprawdzenie kolejnego warunku tylko wtedy, gdy poprzedni był fałszywy.",
            "Można zagnieżdżać instrukcje if tylko do dwóch poziomów.",
            "Instrukcja if-else wykonuje oba bloki kodu niezależnie od warunku."
          ],
          "correct": [1],
          "points": 1
        },

        {
          "id": 6,
          "question": "Jakie są konsekwencje zagnieżdżania wielu instrukcji if zamiast używania elif w sytuacji, gdy chcemy sprawdzić wiele warunków wzajemnie się wykluczających?",
          "answers": [
            "Kod działa szybciej, bo każde if jest niezależne.",
            "Wszystkie warunki if są sprawdzane niezależnie, co może prowadzić do wykonania wielu bloków kodu, zamiast tylko jednego.",
            "elif jest tylko stylistycznym dodatkiem i nie ma znaczenia w działaniu programu.",
            "Zagnieżdżanie wielu if zawsze zapobiega błędom logicznym."
          ],
          "correct": [1],
          "points": 1
        },
        {
          "id": 7,
          "question": "W pętli for w Pythonie możesz użyć instrukcji else. Kiedy zostanie wykonany blok kodu w else?",
          "answers": [
            "Po każdej iteracji pętli",
            "Tylko jeśli pętla zakończyła się normalnie, bez wywołania break",
            "Gdy pętla zawiera instrukcję continue",
            "Blok else nie jest dostępny przy pętlach for"
          ],
          "correct": [1],
          "points": 1
        },


        {
          "id": 8,
          "question": "Co zostanie wypisane po wykonaniu tego kodu? print((lambda x: x * 2)(4))",
          "answers": [
            "4",
            "8",
            "x * 2",
            "Błąd składni"
          ],
          "correct": [1],
          "points": 1
        },
        {
          "id": 9,
          "question": "Kiedy parametry domyślne muszą występować w definicji funkcji?",
          "answers": [
            "Przed argumentami obowiązkowymi",
            "Po argumentach obowiązkowych",
            "W dowolnym miejscu",
            "Tylko na końcu listy argumentów"
          ],
          "correct": [1],
          "points": 1
        },
        {
          "id": 10,
          "question": "Które operacje służą do usuwania elementów z listy? (Wybierz wszystkie poprawne odpowiedzi)",
          "answers": [
            "remove()",
            "append()",
            "pop()",
            "insert()"
          ],
          "correct": [0, 2],
          "points": 2
        },
        {
          "id": 11,
          "question": "Co odróżnia krotki od list w Pythonie? (Wybierz wszystkie poprawne odpowiedzi) ?",
          "answers": [
            "Krotki są niemutowalne, a listy są mutowalne",
            "Krotki mogą być modyfikowane po utworzeniu, a listy nie",
            "Krotki są szybsze i mniej zasobożerne od list",
            "Listy mogą być używane jako klucze w słownikach, a krotki nie",
            "Krotki mogą być hashowalne, dlatego nadają się na klucze w słownikach"
          ],
          "correct": [0, 2, 4],
          "points": 3
        },
        {
          "id": 12,
          "question": "Jaką metodę w Pythonie możesz użyć, aby bezpiecznie uzyskać wartość z słownika, unikając błędu, gdy klucz nie istnieje?",
          "answers": [
            "get()",
            "pop()",
            "del",
            "append()"
          ],
          "correct": [0],
          "points": 1
        },
        {
          "id": 13,
          "question": "Które zdania o obsłudze wyjątków w Pythonie są prawdziwe? (Wybierz wszystkie poprawne.)",
          "answers": [
            "Blok finally wykonuje się zawsze.",
            "Blok else działa, gdy nie ma wyjątku.",
            "raise służy do przechwytywania wyjątków",
            "Można mieć wiele bloków except dla różnych wyjątków.",
            "Exception zawsze bezpiecznie ukrywa błędy."
          ],
          "correct": [0, 1, 3],
          "points": 3
        },
        {
          "id": 14,
          "question": " Która metoda odczytuje cały plik jako jeden łańcuch tekstowy?",
          "answers": [
            "readline()",
            "readlines()",
            "read()",
            "close()"
           
          ],
          "correct": [2],
          "points": 1
        },
        {
          "id": 15,
          "question": " Do czego służy metoda strip() przy odczycie linii z pliku?",
          "answers": [
            "Usuwa białe znaki z końca i początku tekstu",
            "Dodaje nowe linie",
            "Zapisuje dane do pliku",
            "Zamyka plik"
           
          ],
          "correct": [0],
          "points": 1
        }
      ]
    }
    
    
  },
  {
    "id": 3,
    "title": "Wprowadzenie do JavaScript",
    "image": "/images/js.png",
    "duration": "3-5 godzin",
    "category": "Programowanie",
    "categoryGroup": "programowanie"
  },
  {
    "id": 4,
    "title": "React – Pierwsze kroki",
    "image": "/images/react.png",
    "duration": "2-3 godziny",
    "category": "Programowanie",
    "categoryGroup": "programowanie"
  },
  {
    "id": 5,
    "title": "TypeScript dla początkujących",
    "image": "/images/unknow.png",
    "duration": "3-5 godzin",
    "category": "Programowanie",
    "categoryGroup": "programowanie"
  },
  {
    "id": 6,
    "title": "Node.js – Serwery w JavaScript",
    "image": "/images/unknow.png",
    "duration": "1-2 godziny",
    "category": "Programowanie",
    "categoryGroup": "programowanie"
  },
  {
    "id": 7,
    "title": "Git i GitHub w praktyce",
    "image": "/images/unknow.png",
    "duration": "2-3 godziny",
    "category": "Programowanie",
    "categoryGroup": "programowanie"
  },
  {
    "id": 8,
    "title": "Wprowadzenie do chmury obliczeniowej",
    "image": "/images/cloud.jpg",
    "duration": "3-5 godzin",
    "category": "Cloud Computing",
    "categoryGroup": "cloud"
  },
  {
    "id": 9,
    "title": "Microsoft Azure dla początkujących",
    "image": "/images/unknow.png",
    "duration": "1-2 godziny",
    "category": "Cloud Computing",
    "categoryGroup": "cloud"
  },
  {
    "id": 10,
    "title": "Podstawy baz danych i SQL",
    "image": "/images/excel.png",
    "duration": "Mniej niż 1 godzina",
    "category": "Bazy danych",
    "categoryGroup": "bazy danych"
  }
]
